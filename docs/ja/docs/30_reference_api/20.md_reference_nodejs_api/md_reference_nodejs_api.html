<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>
    <style>

html {
    overflow: auto;
    background-color: #fff;
    font-size: 14px;
}

body {
    font-family: 'Open Sans', sans-serif;
    line-height: 1.5;
    color: #4d4e53;
    background-color: white;
}

a, a:visited, a:active {
    color: #0095dd;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

header {
    display: block;
    padding: 0px 4px;
}

tt, code, kbd, samp {
    font-family: Consolas, Monaco, 'Andale Mono', monospace;
}

.class-description {
    font-size: 130%;
    line-height: 140%;
    margin-bottom: 1em;
    margin-top: 1em;
}

.class-description:empty {
    margin: 0;
}

#main {
    float: left;
    width: 70%;
}

section {
    display: block;
    background-color: #fff;
    padding: 12px 24px;
    border-bottom: 1px solid #ccc;
    margin-right: 30px;
}

.variation {
    display: none;
}

.signature-attributes {
    font-size: 60%;
    color: #aaa;
    font-style: italic;
    font-weight: lighter;
}

nav {
    display: block;
    float: right;
    margin-top: 28px;
    width: 30%;
    box-sizing: border-box;
    border-left: 1px solid #ccc;
    padding-left: 16px;
}

nav ul {
    font-family: 'Lucida Grande', 'Lucida Sans Unicode', arial, sans-serif;
    font-size: 100%;
    line-height: 17px;
    padding: 0;
    margin: 0;
    list-style-type: none;
}

nav ul a, nav ul a:visited, nav ul a:active {
    font-family: Consolas, Monaco, 'Andale Mono', monospace;
    line-height: 18px;
    color: #4D4E53;
}

nav h3 {
    margin-top: 12px;
}

nav li {
    margin-top: 6px;
}

footer {
    display: block;
    padding: 6px;
    margin-top: 12px;
    font-style: italic;
    font-size: 90%;
}

h1, h2, h3, h4 {
    font-weight: 200;
    margin: 0;
}

h1 {
    font-family: 'Open Sans Light', sans-serif;
    font-size: 48px;
    letter-spacing: -2px;
    margin: 12px 24px 20px;
}

h2, h3 {
    font-size: 30px;
    font-weight: 700;
    letter-spacing: -1px;
    margin-bottom: 12px;
}

h4 {
    font-size: 18px;
    letter-spacing: -0.33px;
    margin-bottom: 12px;
    color: #4d4e53;
}

h5, .container-overview .subsection-title {
    font-size: 120%;
    font-weight: bold;
    letter-spacing: -0.01em;
    margin: 8px 0 3px 0;
}

h6 {
    font-size: 100%;
    letter-spacing: -0.01em;
    margin: 6px 0 3px 0;
    font-style: italic;
}

.ancestors {
    color: #999;
}

.ancestors a {
    color: #999 !important;
    text-decoration: none;
}

.clear {
    clear: both;
}

.important {
    font-weight: bold;
    color: #950B02;
}

.yes-def {
    text-indent: -1000px;
}

.type-signature {
    color: #aaa;
}

.name, .signature {
    font-family: Consolas, Monaco, 'Andale Mono', monospace;
}

.details {
    margin-top: 14px;
    border-left: 2px solid #DDD;
}

.details dt {
    width: 120px;
    float: left;
    padding-left: 10px;
    padding-top: 6px;
}

.details dd {
    margin-left: 70px;
}

.details ul {
    margin: 0;
}

.details ul {
    list-style-type: none;
}

.details li {
    margin-left: 30px;
    padding-top: 6px;
}

.details pre.prettyprint {
    margin: 0
}

.details .object-value {
    padding-top: 0;
}

.description {
    margin: 0 0 1em 0;
}

.code-caption {
    font-style: italic;
    font-size: 107%;
    margin: 0;
}

.prettyprint {
    border: 1px solid #ddd;
    width: 80%;
    overflow: auto;
}

.prettyprint.source {
    width: inherit;
}

.prettyprint code {
    font-size: 100%;
    line-height: 18px;
    display: block;
    padding: 4px 12px;
    margin: 0;
    background-color: #fff;
    color: #4D4E53;
}

.prettyprint code span.line {
    display: inline-block;
}

.prettyprint.linenums {
    padding-left: 70px;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

.prettyprint.linenums ol {
    padding-left: 0;
}

.prettyprint.linenums li {
    border-left: 3px #ddd solid;
}

.prettyprint.linenums li.selected,
.prettyprint.linenums li.selected * {
    background-color: lightyellow;
}

.prettyprint.linenums li * {
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

.params, .props {
    border-spacing: 0;
    border: 0;
    border-collapse: collapse;
    margin-bottom: 10px;
}

.params .name, .props .name, .name code {
    color: #4D4E53;
    font-family: Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 100%;
}

.params td, .params th, .props td, .props th {
    border: 1px solid #ddd;
    margin: 0px;
    text-align: left;
    vertical-align: top;
    padding: 4px 6px;
    display: table-cell;
}

.params thead tr, .props thead tr {
    background-color: #ddd;
    font-weight: bold;
}

.params .params thead tr, .props .props thead tr {
    background-color: #fff;
    font-weight: bold;
}

.params th, .props th {
    border-right: 1px solid #aaa;
}

.params thead .last, .props thead .last {
    border-right: 1px solid #ddd;
}

.params td.description > p:first-child,
.props td.description > p:first-child {
    margin-top: 0;
    padding-top: 0;
}

.params td.description > p:last-child,
.props td.description > p:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
}

.disabled {
    color: #454545;
}

.subsection {
    margin-top: 10px;
}

.members {
    margin-top: 15px;
}

.members .name {
    margin: 0;
}

.back-to-top, .back-to-top:hover {
    float: right;
    text-decoration: none;
}
    </style>
  </head>

  <body>
    <a name="top" id="top">&nbsp;</a>
<div id="main"><h3> </h3>
<section>
        <article><h1>Welcome to NodeJS Client&#8217;s documentation!</h1>

<p>NodeJS Client for GridDB is developed using GridDB C Client and SWIG (<a class="reference external" href="http://www.swig.org/">http://www.swig.org/</a>).</p>

<p>Functions are the following:</p>
<p>(available)</p>
<ul class="simple">
<li>STRING, BOOL, BYTE, SHORT, INTEGER, LONG, FLOAT, DOUBLE, TIMESTAMP, BLOB type for GridDB</li>
<li>Put/get data</li>
<li>Normal query, aggregation with TQL</li>
<li>Multi-Put/Get/Query (batch processing)</li>
<li>Promise method</li>
<li>null</li>
</ul>
<p>(not available)</p>
<ul class="simple">
<li>GEOMETRY type for GridDB</li>
<li>Timeseries compression</li>
<li>Timeseries-specific function like gsAggregateTimeSeries, gsQueryByTimeSeriesSampling in C Client</li>
<li>Trigger, affinity</li>
</ul>
<p>Please refer to GridDB API reference about Data-type and TQL.</p>
<p>Note:</p>
<ul class="simple">
<li>null is used to represent the absence of a value.</li>
<li>Accuracy of TIMESTAMP for GridDB is in milliseconds. It is the same as return value of Date.getTime().</li>
</ul>
</p></article>
    </section>
<section id="class-global-AggregationResult">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="AggregationResult">
<h2>
        AggregationResult
        </h2>
<div class="class-description"><p>
Stores the result of an aggregation operation.
<br>The type of the stored result depends on the type of aggregation operation and the type of the target Columns.
For specific rules, see the TQL specifications.
<br>The type of obtaining value depends on the stored type.
Float type and long type are only available when a result is of numeric type, and datetime type when a result is of TIMESTAMP type.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="AggregationResult"><span class="type-signature"></span>new AggregationResult<span class="signature">()</span><span class="type-signature"></span></h4>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (2)</h3>
<div class="members">
  <h4 class="name" id="AggregationResult-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :boolean</span></h4>
<div class="description">
      <p>
Get output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="AggregationResult-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (1)</h3>
<h4 class="name" id="AggregationResult-get"><span class="type-signature"></span>get<span class="signature">(type)</span><span class="type-signature"> &rarr; {object}</span></h4>
<div class="description">
    <p>
Returns the aggregation result as the value with specified type.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>type</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">Column type</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-Container">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="Container">
<h2>
        Container
        </h2>
<div class="class-description"><p>CProvides management functions for sets of row having same type.
<br>Each column in GridDB schema is defined by a ContainerInfo. Each container consists of one or more columns.
<br>Mapping table between column type and value in a row object is following:
</p>
<p>
<table style="width:100%;" border="1">
 <tr><th><b>(Column) Type</th><th>string</th><th>boolean</th><th>number</th><th>Date</th><th>Buffer</th></tr>
 <tr><td>STRING</td><td>mapped</td><td> </td><td> </td><td> </td><td> </td></tr>
 <tr><td>BOOL</td><td> </td><td>mapped</td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>BYTE</td><td> </td><td> </td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>SHORT</td><td> </td><td> </td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>INTEGER</td><td> </td><td> </td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>LONG</td><td> </td><td> </td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>FLOAT</td><td> </td><td> </td><td>mapped</td><td> </td><td> </td></tr>
 <tr><td>DOUBLE</td><td> </td><td> </td><td>mapped</td><td></td><td> </td></tr>
 <tr><td>TIMESTAMP</td><td>mapped</td><td> </td><td>mapped</td><td>mapped</td><td> </td></tr>
 <tr><td>BLOB</td><td> </td><td> </td><td> </td><td> </td><td>mapped</td></tr>
</table>
</p>
<p></p>
<p>
TIMESTAMP represents milliseconds since the UNIX epoch (January 1, 1970 00:00:00 UTC) with long type.
<br>TIMESTAMP value suports msec. Range of time is from 1/1/1970 to 12/31/9999 (UTC).
There may be more limitation depending on a GridDB cluster configuration. Cannot store a value out of the range.
<br>There is an upper limit for the number of column and the length of column name.
The value has limitations for rage and size. Please refer to appendix of GridDB API Reference for more detail.
Cannot store a value exceeding these limitations.
<br>A limitation about a row key type, presence of column corresponding to a row key,
and availability of row value updates, may differ for each type derived from the container type.
<br>NULL in GridDB rows can be retained unless the NOT NULL constraint is set.
NOT NULL constraint can be set with columnInfoList object in ContainerInfo when put_container() is called.
<br>About transaction, auto commit mode is active as a default.
In the auto commit mode, each transaction is processed sequentially, and cannot be canceled.
For manual commit mode, transactions before a commit is canceled if there is an error on a cluster node during the transaction via Container instances.
Transaction isolation level supports only READ COMMITTED. Lock granularity may differ for each container type.
<br>When a row is updated, added, deleted, and got a lock for updates, a transaction is generated internally.
This transaction has a valid period.
After some period defined by GridDB is passed from the timing of this transaction for Container instance, any same type of transactions will be not accepted.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="Container"><span class="type-signature"></span>new Container<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>type</code></td>
<td class="type">
<span class="param-type"><a href="#ContainerType">ContainerType</a></span>
</td>
<td class="default">
0
</td>
<td class="description last">Container type</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (4)</h3>
<div class="members">
  <h4 class="name" id="Container-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="Container-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :boolean</span></h4>
<div class="description">
      <p>
Get output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="Container-type"><span class="type-signature"></span>type<span class="type-signature"> :ContainerType</span></h4>
<div class="description">
      <p>
Get type of Container
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="Container-type"><span class="type-signature"></span>type<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set type for Container
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (13)</h3>
<h4 class="name" id="Container-abort"><span class="type-signature"></span>abort<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Rolls back the result of the current transaction and starts a new transaction in the manual commit mode.
</p>
</div>
<h4 class="name" id="Container-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Disconnects with GridDB and releases related resources as necessary.
</p>
</div>
<h4 class="name" id="Container-closeSync"><span class="type-signature"></span>closeSync<span class="signature">()</span><span class="type-signature"> &rarr; {void}</span></h4>
<div class="description">
    <p>
Disconnects with GridDB and releases related resources as necessary.
</p>
</div>
<h4 class="name" id="Container-commit"><span class="type-signature"></span>commit<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Commits the result of the current transaction and start a new transaction in the manual commit mode.
</p>
</div>
<h4 class="name" id="Container-createIndex"><span class="type-signature"></span>createIndex<span class="signature">(indexInfo)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Creates a specified type of index on the specified Column.
<br>Named index can be set with name parameter.
<br>No index cannot be set on a TimeSeries Row key (TIMESTAMP type).
<br>When a transaction is held, uncommitted updates will be rolled back.
<br>If an index is already set on the specified Column, nothing is changed.
<br>When a transaction(s) is active in a target Container, it creates an index after waiting for the transaction(s) to complete.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>indexInfo</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">Index information
                <h6>Properties</h6>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>columnName</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
</td>
<td class="description last">Column name to be processed</td>
        </tr>
<tr>
<td class="name"><code>indexType</code></td>
<td class="type">
<span class="param-type"><a href="#IndexType">IndexType</a></span>
</td>
<td class="default">
DEFAULT
</td>
<td class="description last">Type of index</td>
        </tr>
<tr>
<td class="name"><code>name</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">Name of index</td>
        </tr>
</tbody>
</table>
</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-dropIndex"><span class="type-signature"></span>dropIndex<span class="signature">(indexInfo)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Removes the specified type of index among indexes on the specified Column.
<br>Nothing is changed if the specified index is not found.
<br>When a transaction(s) is active in a target Container, it removes the index after waiting for the transaction(s) to be completed.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>indexInfo</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">Index information
                <h6>Properties</h6>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>columnName</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
</td>
<td class="description last">Column name to create index</td>
        </tr>
<tr>
<td class="name"><code>indexType</code></td>
<td class="type">
<span class="param-type"><a href="#IndexType">IndexType</a></span>
</td>
<td class="default">
DEFAULT
</td>
<td class="description last">Type of index</td>
        </tr>
<tr>
<td class="name"><code>name</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">Name of index</td>
        </tr>
</tbody>
</table>
</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-flush"><span class="type-signature"></span>flush<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Writes the results of earlier updates to a non-volatile storage medium, such as SSD, so as to prevent the data loss even if all cluster nodes stop suddenly.
<br>It can be used for operations which require higher reliability than usual. However, frequent execution of this operation would potentially cause degradation in response time.
<br>The details of behavior, such as the scope of cluster nodes which are the data export targets, will be changed depending on the configuration of GridDB.
</p>
</div>
<h4 class="name" id="Container-get"><span class="type-signature"></span>get<span class="signature">(key, forUpdate)</span><span class="type-signature"> &rarr; {Promise.&lt;object&gt;}</span></h4>
<div class="description">
    <p>
Returns the content of a Row corresponding to Row key.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>key</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">Row key to be processed</td>
        </tr>
<tr>
<td class="name"><code>forUpdate</code></td>
<td class="type">
<span class="param-type">boolean</span>
</td>
<td class="description last">Indicates whether it requests a lock for update or not</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-multiPut"><span class="type-signature"></span>multiPut<span class="signature">(rowList)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Newly creates an arbitrary number of Rows together based on the specified Row objects group.
<br> In the manual commit mode, the target Row is locked.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>rowList</code></td>
<td class="type">
<span class="param-type">Array.<Array.&lt;object&gt;</span>
</td>
<td class="description last">List object corresponding to contents of newly created Row collection</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-put"><span class="type-signature"></span>put<span class="signature">(row)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean&gt;}</span></h4>
<div class="description">
    <p>
Newly creates or update a Row.
<br>If a Column exists which corresponds to the specified Row key, it determines whether to newly create or update a Row, based on the Row key and the state of the Container. If there is no corresponding Row in the Container, it determines to newly create a Row; otherwise, it updates a relevant Row.
<br>If no Column exists which corresponds to the specified Row key, it always creates a new Row.
<br>In the manual commit mode, the target Row is locked.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>row</code></td>
<td class="type">
<span class="param-type">Array.&lt;object&gt;</span>
</td>
<td class="default">
null
</td>
<td class="description last">A list object representing the content of a Row to be newly created or updated.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-query"><span class="type-signature"></span>query<span class="signature">(query)</span><span class="type-signature"> &rarr; {<a href="#Query">Query</a>}</span></h4>
<div class="description">
    <p>
Creates a query to execute the specified TQL statement.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>query</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="description last">TQL statement.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-remove"><span class="type-signature"></span>remove<span class="signature">(key)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean&gt;}</span></h4>
<div class="description">
    <p>
Removes a Row corresponding to Row key.
<br> In the manual commit mode, the target Row is locked.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>key</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">Row key to be processed</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Container-setAutoCommit"><span class="type-signature"></span>setAutoCommit<span class="signature">(enabled)</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
Change the setting of the commit mode.
<br> In the auto commit mode, the transaction state cannot be controlled directly and change operations are committed sequentially. If the auto commit mode is disabled, i.e. in the manual commit mode, as long as the transaction has not timed out or commit() has been invoked directly, the same transaction will continue to be used in this Container and change operations will not be committed.
<br> When the auto commit mode is switched from disabled to enabled, uncommitted updates are committed implicitly. Unless the commit mode is changed, the state of the transaction will not be changed.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>enabled</code></td>
<td class="type">
<span class="param-type">boolean</span>
</td>
<td class="description last">Indicates whether it enables auto commit mode or not. if True, auto commit mode is enabled. if False, manual commit mode is enabled.</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-GSException">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="GSException">
<h2>
        GSException
        </h2>
<div class="class-description"><p>
Represents the exception for GridDB.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="GSException"><span class="type-signature"></span>new GSException<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>isTimeout</code></td>
<td class="type">
<span class="param-type">boolean</span>
</td>
<td class="default">
false
</td>
<td class="description last">Read-only attribute to determine whether the result of the requested process shows the error code corresponding to the error that occurred when the requested process is not completed within a predetermined time</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (7)</h3>
<h4 class="name" id="GSException-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {void}</span></h4>
<div class="description">
    <p>
Disconnects with GridDB and releases related resources as necessary.
</p>
</div>
<h4 class="name" id="GSException-getErrorCode"><span class="type-signature"></span>getErrorCode<span class="signature">(stackIndex)</span><span class="type-signature"> &rarr; {number}</span></h4>
<div class="description">
    <p>
Returns the error code of last error related to this resource.
<br> 0 indicates the successful execution for GridDB instructions.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>stackIndex</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The index of error stack. A valid result will be returned only if a value which has more than 0 and less than the stack size is specified.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="GSException-getErrorStackSize"><span class="type-signature"></span>getErrorStackSize<span class="signature">()</span><span class="type-signature"> &rarr; {number}</span></h4>
<div class="description">
    <p>
Returns the stack size of last error information related to this resource.
<br> Error information has become a stack structure. A large stack number corresponds to the more direct cause of the error.
</p>
</div>
<h4 class="name" id="GSException-getLocation"><span class="type-signature"></span>getLocation<span class="signature">(stackIndex)</span><span class="type-signature"> &rarr; {string}</span></h4>
<div class="description">
    <p>
Returns the error location of the internal module to the message of last error related to this resource.
<br> It might always return empty string depending on the settings.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>stackIndex</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The index of error stack. A valid result will be returned only if a value which has more than 0 and less than the stack size is specified.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="GSException-getMessage"><span class="type-signature"></span>getMessage<span class="signature">(stackIndex)</span><span class="type-signature"> &rarr; {string}</span></h4>
<div class="description">
    <p>
Returns the message of last error related to this resource.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>stackIndex</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The index of error stack. A valid result will be returned only if a value which has more than 0 and less than the stack size is specified.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="GSException-isTimeout"><span class="type-signature"></span>isTimeout<span class="signature">()</span><span class="type-signature"> &rarr; {boolean}</span></h4>
<div class="description">
    <p>
 Determine whether the result of the requested process shows the error code corresponding to the error that occurred when the requested process is not completed within a predetermined time.
</p>
</div>
<h4 class="name" id="GSException-what"><span class="type-signature"></span>what<span class="signature">()</span><span class="type-signature"> &rarr; {string}</span></h4>
<div class="description">
    <p>
Returns the message include error code and error message
</p>
</div>
</div>
</article>

</section>
<section id="class-global-PartitionController">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="PartitionController">
<h2>
        PartitionController
        </h2>
<div class="class-description"><p>
Controller for acquiring and processing the partition status.
<br>A partition is a theoretical region where data is stored. It is used to perform operations based on the data arrangement in a GridDB cluster.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="PartitionController"><span class="type-signature"></span>new PartitionController<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>partitionCount</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="default">
null
</td>
<td class="description last">The number of partitions in the target GridDB cluster. (Read-only attribute)</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (1)</h3>
<div class="members">
  <h4 class="name" id="PartitionController-partitionCount"><span class="type-signature"></span>partitionCount<span class="type-signature"> :number</span></h4>
<div class="description">
      <p>
Get partition count
<br> Get the number of partitions in the target GridDB cluster.
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (5)</h3>
<h4 class="name" id="PartitionController-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
The connection status with GridDB is released and related resources are released where necessary.
</p>
</div>
<h4 class="name" id="PartitionController-closeSync"><span class="type-signature"></span>closeSync<span class="signature">()</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
The connection status with GridDB is released and related resources are released where necessary.
</p>
</div>
<h4 class="name" id="PartitionController-getContainerCount"><span class="type-signature"></span>getContainerCount<span class="signature">(partitionIndex)</span><span class="type-signature"> &rarr; {Promise.&lt;number&gt;}</span></h4>
<div class="description">
    <p>
Get the total number of containers belonging to a specified partition.
<br> The calculated quantity when determining the number of containers is generally not dependent on the number of containers.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>partitionIndex</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The partition index, from 0 to the number of partitions minus one</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="PartitionController-getContainerNames"><span class="type-signature"></span>getContainerNames<span class="signature">(partitionIndex, start, limit)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;string&gt;&gt;}</span></h4>
<div class="description">
    <p>
Get a list of the Container names belonging to a specified partition.
<br> For the specified partition, the sequence of the list of acquisition results before and after will not be changed when the relevant Container is excluded even if a Container is newly created, its composition changed or the Container is deleted. All other lists are compiled in no particular order. No duplicate names will be included.
<br> If the upper limit of the number of acquisition cases is specified, the cases will be cut off starting from the ones at the back if the upper limit is exceeded. If no relevant specified condition exists, a blank list is returned.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>partitionIndex</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The partition index, from 0 to the number of partitions minus one</td>
        </tr>
<tr>
<td class="name"><code>start</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The start position of the acquisition range. A value must be greater than or equal to 0</td>
        </tr>
<tr>
<td class="name"><code>limit</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="description last">The upper limit of the number of cases acquired. It is optional. If not specified or limit < 0, it is considered as no upper limit.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="PartitionController-getPartitionIndexOfContainer"><span class="type-signature"></span>getPartitionIndexOfContainer<span class="signature">(containerName)</span><span class="type-signature"> &rarr; {Promise.&lt;number&gt;}</span></h4>
<div class="description">
    <p>
Get the partition index corresponding to the specified Container name.
<br> Once a GridDB cluster is constructed, there will not be any changes in the partitions of the destination that the Container belongs to and the partition index will also be fixed. Whether there is a Container corresponding to the specified name or not does not depend on the results.
<br> Information required in the computation of the partition index is cached and until the next cluster failure and cluster node failure is detected, no inquiry will be sent to the GridDB cluster again.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>containerName</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="description last">Container name</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-Query">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="Query">
<h2>
        Query
        </h2>
<div class="class-description"><p>
Provides the functions of holding the information about a query related to a specific Container, specifying the options for fetching and retrieving the result.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="Query"><span class="type-signature"></span>new Query<span class="signature">()</span><span class="type-signature"></span></h4>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (5)</h3>
<h4 class="name" id="Query-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Releases related resources properly.
</p>
</div>
<h4 class="name" id="Query-closeSync"><span class="type-signature"></span>closeSync<span class="signature">()</span><span class="type-signature"> &rarr; {void}</span></h4>
<div class="description">
    <p>
Releases related resources properly.
</p>
</div>
<h4 class="name" id="Query-fetch"><span class="type-signature"></span>fetch<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;<a href="#RowSet">RowSet</a>&gt;}</span></h4>
<div class="description">
    <p>
It locks all target Rows if True is specified as forUpdate . If the target Rows are locked, update operations on the Rows by any other transactions are blocked while a relevant transaction is active. True can be specified only if the auto commit mode is disabled on a relevant Container.
<br> When new set of Rows are obtained, any Row operation via RowSet as the last result of specified query is prohibited.
<br> If the system tries to acquire a large number of Rows all at once, the upper limit of the communication buffer size managed by the GridDB node may be reached, possibly resulting in a failure. Refer to "System limiting values" in the Appendix of GridDB API Reference for the upper limit size.
</p>
</div>
<h4 class="name" id="Query-getRowSet"><span class="type-signature"></span>getRowSet<span class="signature">()</span><span class="type-signature"> &rarr; {<a href="#RowSet">RowSet</a>}</span></h4>
<div class="description">
    <p>
Returns RowSet as the latest result.
<br> Once RowSet is returned, it cannot be obtained until the new query is executed.
</p>
</div>
<h4 class="name" id="Query-setFetchOptions"><span class="type-signature"></span>setFetchOptions<span class="signature">(options)</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
Sets an fetch options for a result acquisition.
<br> Once RowSet is returned, it cannot be obtained until the new query is executed.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>options</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">The options for fetching the result of a query
                <h6>Properties</h6>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>limit</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="default">
null
</td>
<td class="description last">Used to set the maximum number of Rows to be fetched</td>
        </tr>
</tbody>
</table>
</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-QueryAnalysisEntry">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="QueryAnalysisEntry">
<h2>
        QueryAnalysisEntry
        </h2>
<div class="class-description"><p>
Represents one of information entries composing a query plan and the results of analyzing a query operation.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="QueryAnalysisEntry"><span class="type-signature"></span>new QueryAnalysisEntry<span class="signature">()</span><span class="type-signature"></span></h4>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (1)</h3>
<h4 class="name" id="QueryAnalysisEntry-get"><span class="type-signature"></span>get<span class="signature">()</span><span class="type-signature"> &rarr; {Array}</span></h4>
<div class="description">
    <p>
Returns one of information entries composing a query plan and the results of analyzing a query operation.
</p>
</div>
</div>
</article>

</section>
<section id="class-global-RowKeyPredicate">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="RowKeyPredicate">
<h2>
        RowKeyPredicate
        </h2>
<div class="class-description"><p>
Represents the condition that a row key satisfies.
<br> This is used as the search condition in Store.multiGet().
<br> There are two types of conditions, range condition and individual condition. The two types of conditions cannot be specified at the same time. If the condition is not specified, it means that the condition is satisfied in all the target row keys.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="RowKeyPredicate"><span class="type-signature"></span>new RowKeyPredicate<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>keyType</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">The type of Row key used as a search condition. (Read-only attribute)</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (2)</h3>
<div class="members">
  <h4 class="name" id="RowKeyPredicate-keyType"><span class="type-signature"></span>keyType<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set type of RowkeyPredicate
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="RowKeyPredicate-keyType"><span class="type-signature"></span>keyType<span class="type-signature"> :Type</span></h4>
<div class="description">
      <p>
Get type of RowkeyPredicate
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (4)</h3>
<h4 class="name" id="RowKeyPredicate-getDistinctKeys"><span class="type-signature"></span>getDistinctKeys<span class="signature">()</span><span class="type-signature"> &rarr; {Array.&lt;object&gt;}</span></h4>
<div class="description">
    <p>
Returns a list of the values of the Row keys that configure the individual condition.
</p>
</div>
<h4 class="name" id="RowKeyPredicate-getRange"><span class="type-signature"></span>getRange<span class="signature">()</span><span class="type-signature"> &rarr; {Array.&lt;object, object&gt;}</span></h4>
<div class="description">
    <p>
Returns the value of Row key at the start and end position of the range condition.
</p>
</div>
<h4 class="name" id="RowKeyPredicate-setDistinctKeys"><span class="type-signature"></span>setDistinctKeys<span class="signature">(keys)</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
Sets list of the elements in the individual condition.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>keys</code></td>
<td class="type">
<span class="param-type">Array.&lt;object&gt;</span>
</td>
<td class="description last">List of the elements in the individual condition</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="RowKeyPredicate-setRange"><span class="type-signature"></span>setRange<span class="signature">(start, end)</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
Sets the value of Row key as the start and end position of the range conditions.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>start</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">The value of the Row key as the start position</td>
        </tr>
<tr>
<td class="name"><code>end</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">The value of the Row key as the end position</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-RowSet">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="RowSet">
<h2>
        RowSet
        </h2>
<div class="class-description"><p>
Manages a set of Rows obtained by a query.
<br> It has a function of per-Row and per-Row-field manipulation and holds a cursor state to specify a target Row. The cursor is initially located just before the head of a Row set.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="RowSet"><span class="type-signature"></span>new RowSet<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>type</code></td>
<td class="type">
<span class="param-type"><a href="#RowSetType">RowSetType</a></span>
</td>
<td class="default">
CONTAINER_ROWS
</td>
<td class="description last">The type of content that can be extracted from RowSet. (Read-only attribute)</td>
        </tr>
<tr>
<td class="name"><code>size</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="default">
null
</td>
<td class="description last">The size of Row set. (Read-only attribute)</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (4)</h3>
<div class="members">
  <h4 class="name" id="RowSet-size"><span class="type-signature"></span>size<span class="type-signature"> :number</span></h4>
<div class="description">
      <p>
Get size of row set
<br> The number of Row when a Row set is created
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="RowSet-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :boolean</span></h4>
<div class="description">
      <p>
Get output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="RowSet-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="RowSet-type"><span class="type-signature"></span>type<span class="type-signature"> :RowSetType</span></h4>
<div class="description">
      <p>
Get type of row set
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (4)</h3>
<h4 class="name" id="RowSet-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Releases related resources as necessary.
</p>
</div>
<h4 class="name" id="RowSet-closeSync"><span class="type-signature"></span>closeSync<span class="signature">()</span><span class="type-signature"></span></h4>
<div class="description">
    <p>
Releases related resources as necessary.
</p>
</div>
<h4 class="name" id="RowSet-hasNext"><span class="type-signature"></span>hasNext<span class="signature">()</span><span class="type-signature"> &rarr; {boolean}</span></h4>
<div class="description">
    <p>
Returns whether a Row set has at least one Row ahead of the current cursor position.
</p>
</div>
<h4 class="name" id="RowSet-next"><span class="type-signature"></span>next<span class="signature">()</span><span class="type-signature"> &rarr; {Array.&lt;object&gt;|<a href="#AggregationResult">AggregationResult</a>|<a href="#QueryAnalysisEntry">QueryAnalysisEntry</a>}</span></h4>
<div class="description">
    <p>
Moves the cursor to the next Row in a Row set and returns the Row object at the moved position.
</p>
</div>
</div>
</article>

</section>
<section id="class-global-Store">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="Store">
<h2>
        Store
        </h2>
<div class="class-description"><p>
Provides functions to manipulate the entire data managed in one GridDB system.
<br> A function to add, delete, or change the composition of Collection and TimeSeries Containers as well as to process the Rows constituting a Container is provided.
<br> Regardless of container types, etc., multiple container names different only in uppercase and lowercase ASCII characters cannot be defined in a database.  See the GridDB Technical Reference for the details. In the operations specifying a container name, uppercase and lowercase ASCII characters are identified as the same unless otherwise noted.
<br> Thread safety of each method is not guaranteed.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="Store"><span class="type-signature"></span>new Store<span class="signature">()</span><span class="type-signature"></span></h4>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>partitionController</code></td>
<td class="type">
<span class="param-type"><a href="#PartitionController">PartitionController</a></span>
</td>
<td class="description last">PartitionController instance corresponding to GridDB cluster. (Read-only attribute)</td>
        </tr>
</tbody>
</table>
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (3)</h3>
<div class="members">
  <h4 class="name" id="Store-partitionController"><span class="type-signature"></span>partitionController<span class="type-signature"> :PartitionController</span></h4>
<div class="description">
      <p>
Get PartitionController corresponding to GridDB cluster.
<br> It can be used until the specified GSGridStore is closed.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="Store-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :boolean</span></h4>
<div class="description">
      <p>
Get output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
<div class="members">
  <h4 class="name" id="Store-timestampOutput"><span class="type-signature"></span>timestampOutput<span class="type-signature"> :void</span></h4>
<div class="description">
      <p>
Set output type for row field timestamp.
<br> The default of output timestsamp is datatime.
</p>
  </div>
</div>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (11)</h3>
<h4 class="name" id="Store-close"><span class="type-signature"></span>close<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Disconnects with GridDB without releases related resources.
</p>
</div>
<h4 class="name" id="Store-closeSync"><span class="type-signature"></span>closeSync<span class="signature">()</span><span class="type-signature"> &rarr; {void}</span></h4>
<div class="description">
    <p>
Disconnects with GridDB without releases related resources (synchronously).
</p>
</div>
<h4 class="name" id="Store-createRowKeyPredicate"><span class="type-signature"></span>createRowKeyPredicate<span class="signature">(type)</span><span class="type-signature"> &rarr; {Promise.&lt;<a href="#RowKeyPredicate">RowKeyPredicate</a>&gt;}</span></h4>
<div class="description">
    <p>
Creates a matching condition with the specified Type as the type of Row key.
<br> The target Container must have a Row key, and it must be the same type as the specified Type.
<br> The type of Row key that can be set must be the same type that is allowed by the individual Container type derived from Container.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>type</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">The type of Row key used as a matching condition.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-createRowKeyPredicateSync"><span class="type-signature"></span>createRowKeyPredicateSync<span class="signature">(type)</span><span class="type-signature"> &rarr; {<a href="#RowKeyPredicate">RowKeyPredicate</a>}</span></h4>
<div class="description">
    <p>
Creates a matching condition with the specified Type as the type of Row key (synchronously).
<br> The target Container must have a Row key, and it must be the same type as the specified Type.
<br> The type of Row key that can be set must be the same type that is allowed by the individual Container type derived from Container.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>type</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">The type of Row key used as a matching condition.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-dropContainer"><span class="type-signature"></span>dropContainer<span class="signature">(name)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Delete a Container with the specified name.
<br> If the specified Container is already deleted, nothing is changed.
<br> When a transaction(s) is active in a target Container, it deletes the Container after waiting for the transaction completion.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>name</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="description last">Container name to be processed.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-fetchAll"><span class="type-signature"></span>fetchAll<span class="signature">(queryList)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
Query execution and fetch is carried out on a specified arbitrary number of Query , with the request unit enlarged as much as possible.
<br> For each Query included in a specified query column, perform a similar query execution and fetch as when Query.fetch() is performed individually and set the RowSet in the results. Use getRowSet() to extract the execution results of each Query . However, unlike the case when carried out individually, the target node is requested for the same storage destination, etc. with a unit that is as large as possible. Based on this, the larger the number of elements in the list, the higher is the possibility that the number of correspondences with the target node will be reduced. Query in a list are not executed in any particular order.
<br> Only a Query that has not been closed, including corresponding Container acquired via the specified Store instance, can be included in a specified query column. Like a fetch() , the Row operations via RowSet finally generated and held by each Query will be unavailable. If the same instance is included multiple times in an array, the behavior will be the same as the case in which the respective instances differ.
<br> Like other Container or Row operations, consistency between Containers is not guaranteed. Therefore, the processing results for a certain Container may be affected by other operation commands that have been completed prior to the start of the process.
<br> The commit mode of each Container corresponding to the specified Query can be used in either the auto commit mode or manual commit mode. The transaction status is reflected in the execution results of the query. If the operation is completed normally, the corresponding transaction of each Container will not be aborted so long as the transaction timeout time has not been reached.
<br> If an exception occurs in the midst of processing each Query , a new RowSet may be set for only some of the Query . In addition, uncommitted transactions of each Query corresponding to the designated Container may be aborted.
<br> If the system tries to acquire a large number of Rows all at once, the upper limit of the communication buffer size managed by the GridDB node may be reached, possibly resulting in a failure. Refer to "System limiting values" in the Appendix of GridDB API Reference for the upper limit size.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>queryList</code></td>
<td class="type">
<span class="param-type">Array.&lt;<a href="#Query">Query</a>&gt;</span>
</td>
<td class="description last">A list of target Queries</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-getContainer"><span class="type-signature"></span>getContainer<span class="signature">(name)</span><span class="type-signature"> &rarr; {Promise.&lt;<a href="#Container">Container</a>&gt;}</span></h4>
<div class="description">
    <p>
Get a Container instance whose Rows can be processed using a Row.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>name</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="description last">Container name to be processed</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-getContainerInfo"><span class="type-signature"></span>getContainerInfo<span class="signature">(name)</span><span class="type-signature"> &rarr; {Promise.&lt;ContainerInfo&gt;}</span></h4>
<div class="description">
    <p>
Get information related to a Container with the specified name.
<br> A name stored in GridDB is set for the Container name to be included in a returned ContainerInfo . Therefore, compared to the specified Container name, the notation of the ASCII uppercase characters and lowercase characters may differ.
<br> When a transaction(s) is active in a target Container, it deletes the Container after waiting for the transaction completion.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>name</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="description last">Container name to be processed.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-multiGet"><span class="type-signature"></span>multiGet<span class="signature">(predicateEntry)</span><span class="type-signature"> &rarr; {object.&lt;string, Array.&lt;object&gt;&gt;}</span></h4>
<div class="description">
    <p>
Returns an arbitrary number and range of Rows in any Container based on the specified conditions, with the request unit enlarged as much as possible.
<br> Returns the Row contents in accordance with the conditions included in the specified entry column, similar to invoking Container.get() or Query.fetch() individually. However, unlike the case when carried out individually, the target node is requested for the same storage destination, etc. with a unit that is as large as possible. Based on this, the larger the total number of Rows conforming to the conditions and the larger the total number of target Containers, the higher is the possibility that the number of correspondences with the target node will be reduced.
<br> A specified condition entry column is composed of an arbitrary number of condition entries that adopt the Container name as the key and the acquisition condition represented by RowKeyPredicate as the value. Multiple instances with the same RowKeyPredicate can also be included. In addition, a subject Container may be a mixture of different Container types and column layouts. However, there are some acquisition conditions that cannot be evaluated due to the composition of the Container. Refer to the definitions of the various setting functions for RowKeyPredicate for the specific restrictions. In addition, the specified Container name must be a real Container. It is prohibited to set null in the Container name or the acquisition condition.
<br> An acquired entry column is composed of entries that adopt the Container name as its key and column of Row objects as its value. All entries included in a specified entry as acquisition conditions are included in an acquired entry column. If multiple entries pointing the same Container are included in a specified condition entry column, a single entry consolidating these is stored in the acquired entry column. If multiple Row objects are included in the same list, the stored order follows the Container type and the definition of the individual Container type derived from the corresponding Container . If there is no Row corresponding to the specified Container, the number of elements in corresponding column of Row object will be 0.
<br> Like other Container or Row operations, consistency between Containers is not guaranteed. Therefore, the processing results for a certain Container may be affected by other operation commands that have been completed prior to the start of the process.
<br> Like Container.get() or Query.fetch() , a transaction cannot be maintained and requests for updating locks cannot be made.
<br> If the system tries to acquire a large number of Rows all at once, the upper limit of the communication buffer size managed by the GridDB node may be reached, possibly resulting in a failure. Refer to "System limiting values" in the Appendix of GridDB API Reference for the upper limit size.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>predicateEntry</code></td>
<td class="type">
<span class="param-type">object.&lt;string, <a href="#RowKeyPredicate">RowKeyPredicate</a>&gt;</span>
</td>
<td class="description last">The column of condition entry consisting of a combination of the target Container name and the acquisition condition. It consists of the array of RowKeyPredicate.</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-multiPut"><span class="type-signature"></span>multiPut<span class="signature">(containerEntry)</span><span class="type-signature"> &rarr; {Promise.&lt;void&gt;}</span></h4>
<div class="description">
    <p>
New creation or update operation is carried out on an arbitrary number of rows of a Container, with the request unit enlarged as much as possible.
<br> For each Row object included in a specified entry column, a new creation or update operation is carried out just like the case when Container.put() is invoked individually. However, unlike the case when carried out individually, the target node is requested for the same storage destination, etc. with a unit that is as large as possible. Based on this, the larger the total number of Row objects specified and the larger the total number of target Containers, the higher is the possibility that the number of correspondences with the target node will be reduced.
<br> A specified entry column is composed of an arbitrary number of entries that adopt the Container name as its key and the column of Row objects as its value. A subject Container may be a mixture of different Container types and column layouts. However, the Containers must already exist. Null can not be set as the Container name in the entry column. Also null can not be set as the array address to the column of Row objects if the number of elements in the column of Row objects is positive value.
<br> An arbitrary number of Row with the same column layout as the subject Container can be included in each column of Row objects. In the current version, all the column order must also be the same. The Container cannot include null as an element of the column of Row objects. Depending on the Container type and setting, the same restrictions as Container.put() are established for the contents of Rows that can be operated. If there are multiple columns of Row objects having the same Row key targeting the same Container in the designated entry column, the contents of the rear-most Row object having a Row key with the same value will be reflected using the element order of entry column as a reference if it is between different lists, or the element order of the column of Row object as a reference if it is within the same column of Row object. The transaction cannot be maintained and the lock cannot continue to be retained. However, if the lock that affects the target Row is secured by an existing transaction, the system will continue to wait for all the locks to be released. Like other Container or Row operations, consistency between Containers is not guaranteed. Therefore, the processing results for a certain Container may be affected by other operation commands that have been completed prior to the start of the process. If an error occurs in the midst of processing a Container and its Rows, only the results for some of the Rows of some of the Containers may remain reflected.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>containerEntry</code></td>
<td class="type">
<span class="param-type">object.&lt;string, Array.&lt;Array.&lt;object&gt;&gt;&gt;</span>
</td>
<td class="description last">dict-type data consisting of container name and the list of Row objects</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="Store-putContainer"><span class="type-signature"></span>putContainer<span class="signature">(info, modifiable)</span><span class="type-signature"> &rarr; {Promise.&lt;<a href="#Container">Container</a>&gt;}</span></h4>
<div class="description">
    <p>
Newly creates or update a Container with the specified ContainerInfo.
<br> It can be used only for RowSet obtained with locking enabled.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>info</code></td>
<td class="type">
<span class="param-type">ContainerInfo</span>
</td>
<td class="default">
</td>
<td class="description last">Container information to be processed.</td>
        </tr>
<tr>
<td class="name"><code>modifiable</code></td>
<td class="type">
<span class="param-type">boolean</span>
</td>
<td class="default">
false
</td>
<td class="description last">Indicates whether the column layout of the existing Container can be modified or not.</td>
        </tr>
</tbody>
</table>
</div>
</article>

</section>
<section id="class-global-StoreFactory">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="StoreFactory">
<h2>
        StoreFactory
        </h2>
<div class="class-description"><p>
Manage a Store instance.
<br> It manages the client settings shared by Store instances and used connections.
<br> To access GridDB, you need to get a Store instance using this Factory.
</p></div>
</header>

<article>
    <div class="container-overview">
<h2>Constructor</h2>
<h4 class="name" id="StoreFactory"><span class="type-signature"></span>new StoreFactory<span class="signature">()</span><span class="type-signature"></span></h4>
</div>
<div class="subsection">
          <h3 class="subsection-title">Methods (3)</h3>
<h4 class="name" id="StoreFactory-getInstance"><span class="type-signature">(static) </span>getInstance<span class="signature">()</span><span class="type-signature"> &rarr; {<a href="#StoreFactory">StoreFactory</a>}</span></h4>
<div class="description">
    <p>
Returns a StoreFactory instance.
</p>
</div>
<h4 class="name" id="StoreFactory-getStore"><span class="type-signature"></span>getStore<span class="signature">(options)</span><span class="type-signature"> &rarr; {<a href="#Store">Store</a>}</span></h4>
<div class="description">
    <p>
Returns a Store with the specified properties.
<br> When obtaining Store, it just searches for the name of a master node (hereafter, a master) administering each Container as necessary, but authentication is not performed. When a client really needs to connect to a node corresponding to each Container , authentication is performed.
<br> A new Store instance is created by each call of this method. Operations on different Store instances and related resources are thread safe. That is, if some two resources are each created based on Store instances or they are just Store instances, and if they are related to different Store instances respectively, any function related to one resource can be called, no matter when a function related to the other resource may be called from any thread. However, since thread safety is not guaranteed for Store itself, it is not allowed to call a method of a single Store instance from two or more threads at an arbitrary time.
</p>
</div>
<h5>Parameters:</h5>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>options</code></td>
<td class="type">
<span class="param-type">object</span>
</td>
<td class="description last">Information to get store.
                <h6>Properties</h6>
<table class="params">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>host</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A destination host name.</td>
        </tr>
<tr>
<td class="name"><code>port</code></td>
<td class="type">
<span class="param-type">number</span>
</td>
<td class="default">
null
</td>
<td class="description last">A destination port number.</td>
        </tr>
<tr>
<td class="name"><code>clusterName</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A cluster name.</td>
        </tr>
<tr>
<td class="name"><code>database</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">Name of the database to be connected.</td>
        </tr>
<tr>
<td class="name"><code>username</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A user name.</td>
        </tr>
<tr>
<td class="name"><code>password</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A password for user authentication.</td>
        </tr>
<tr>
<td class="name"><code>notificationMember</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A list of address and port pairs in cluster.</td>
        </tr>
<tr>
<td class="name"><code>notificationProvider</code></td>
<td class="type">
<span class="param-type">string</span>
</td>
<td class="default">
null
</td>
<td class="description last">A URL of address provider.</td>
        </tr>
</tbody>
</table>
</td>
        </tr>
</tbody>
</table>
<h4 class="name" id="StoreFactory-getVersion"><span class="type-signature"></span>getVersion<span class="signature">()</span><span class="type-signature"> &rarr; {string}</span></h4>
<div class="description">
    <p>
Returns the version of this client.
</p>
</div>
</div>
</article>

</section>
<section id="globalobj-undefined-undefined">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="">
<h2>
</h2>
</header>

<article>
    <div class="container-overview">
</div>
<div class="subsection">
          <h3 class="subsection-title">Members (6)</h3>
<div class="members">
  <h4 class="name" id="ContainerType"><span class="type-signature">(constant) </span>ContainerType<span class="type-signature"> :ContainerType</span></h4>
<div class="description">
      Represents the type of a Container.
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>COLLECTION</code></td>
<td class="type">
<span class="param-type"><a href="#ContainerType">ContainerType</a></span>
</td>
<td class="description last">Collection container</td>
        </tr>
<tr>
<td class="name"><code>TIME_SERIES</code></td>
<td class="type">
<span class="param-type"><a href="#ContainerType">ContainerType</a></span>
</td>
<td class="description last">TimeSeries container</td>
        </tr>
</tbody>
</table>
</div>
<div class="members">
  <h4 class="name" id="IndexType"><span class="type-signature">(constant) </span>IndexType<span class="type-signature"> :IndexType</span></h4>
<div class="description">
      Represents the type(s) of indexes set on a Container.
<br> If DEFAULT is specified, the following types of indexes are selected depending on the Container type and corresponding Column type.
<p>
<table style="width:100%;" border="1">
 <tr><th><b>(Column) Type</b></th><th><b>Collection</b></th><th><b>TimeSeries</b></th></tr>
 <tr><td>STRING</td><td>TREE</td><td>TREE</td></tr>
 <tr><td>BOOL</td><td>TREE</td><td>TREE</td></tr>
 <tr><td>Numeric type</td><td>TREE</td><td>TREE</td></tr>
 <tr><td>TIMESTAMP</td><td>TREE</td><td>TREE</td></tr>
 <tr><td>BLOB</td><td>(-)</td><td>(-)</td></tr>
</table>
</p>
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>DEFAULT</code></td>
<td class="type">
<span class="param-type"><a href="#IndexType">IndexType</a></span>
</td>
<td class="description last">Indicates a default index.</td>
        </tr>
<tr>
<td class="name"><code>TREE</code></td>
<td class="type">
<span class="param-type"><a href="#IndexType">IndexType</a></span>
</td>
<td class="description last">Indicates a tree index. This index can be applied to STRING/BOOL/BYTE/SHORT/INTEGER/LONG/FLOAT/DOUBLE/TIMESTAMP types of Columns of any type of Container, except the Column corresponding to the Row key of TimeSeries.</td>
        </tr>
<tr>
<td class="name"><code>HASH</code></td>
<td class="type">
<span class="param-type"><a href="#IndexType">IndexType</a></span>
</td>
<td class="description last">Indicates a hash index. This type of index can be set on STRING/BOOL/BYTE/SHORT/INTEGER/LONG/FLOAT/DOUBLE/TIMESTAMP types of Columns in Collection. It cannot be set on Columns in TimeSeries.</td>
        </tr>
</tbody>
</table>
</div>
<div class="members">
  <h4 class="name" id="RowSetType"><span class="type-signature">(constant) </span>RowSetType<span class="type-signature"> :RowSetType</span></h4>
<div class="description">
      Represents the type of content that can be extracted from RowSet.
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>CONTAINER_ROWS</code></td>
<td class="type">
<span class="param-type"><a href="#RowSetType">RowSetType</a></span>
</td>
<td class="description last">Row set in a Container</td>
        </tr>
<tr>
<td class="name"><code>AGGREGATION_RESULT</code></td>
<td class="type">
<span class="param-type"><a href="#RowSetType">RowSetType</a></span>
</td>
<td class="description last">Aggregation result</td>
        </tr>
<tr>
<td class="name"><code>QUERY_ANALYSIS</code></td>
<td class="type">
<span class="param-type"><a href="#RowSetType">RowSetType</a></span>
</td>
<td class="description last">Represents one of information entries composing a query plan and the results of analyzing a query operation.</td>
        </tr>
</tbody>
</table>
</div>
<div class="members">
  <h4 class="name" id="TimeUnit"><span class="type-signature">(constant) </span>TimeUnit<span class="type-signature"> :TimeUnit</span></h4>
<div class="description">
      Represents the unit of the elapsed time period of a Row to be used as the basis of the validity period.
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>YEAR</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>MONTH</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>DAY</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>HOUR</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>MINUTE</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>SECOND</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
<tr>
<td class="name"><code>MILLISECOND</code></td>
<td class="type">
<span class="param-type"><a href="#TimeUnit">TimeUnit</a></span>
</td>
<td class="description last"></td>
        </tr>
</tbody>
</table>
</div>
<div class="members">
  <h4 class="name" id="Type"><span class="type-signature">(constant) </span>Type<span class="type-signature"> :Type</span></h4>
<div class="description">
      Represents the type of field values in GridDB.
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>STRING</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">STRING type</td>
        </tr>
<tr>
<td class="name"><code>BOOL</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">BOOL type</td>
        </tr>
<tr>
<td class="name"><code>BYTE</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">BYTE type</td>
        </tr>
<tr>
<td class="name"><code>SHORT</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">SHORT type</td>
        </tr>
<tr>
<td class="name"><code>INTEGER</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">INTEGER type</td>
        </tr>
<tr>
<td class="name"><code>LONG</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">LONG type</td>
        </tr>
<tr>
<td class="name"><code>FLOAT</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">FLOAT type</td>
        </tr>
<tr>
<td class="name"><code>DOUBLE</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">DOUBLE type</td>
        </tr>
<tr>
<td class="name"><code>TIMESTAMP</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">TIMESTAMP type</td>
        </tr>
<tr>
<td class="name"><code>BLOB</code></td>
<td class="type">
<span class="param-type"><a href="#Type">Type</a></span>
</td>
<td class="description last">BLOB type</td>
        </tr>
</tbody>
</table>
</div>
<div class="members">
  <h4 class="name" id="TypeOption"><span class="type-signature">(constant) </span>TypeOption<span class="type-signature"> :TypeOption</span></h4>
<div class="description">
      Represents NOT NULL constrant.
  </div>
<h5 class="subsection-title">Properties:</h5>
<table class="props">
    <thead>
    <tr>
<th>Name</th>
<th>Type</th>
<th class="last">Description</th>
    </tr>
    </thead>
<tbody>
<tr>
<td class="name"><code>NULLABLE</code></td>
<td class="type">
<span class="param-type"><a href="#TypeOption">TypeOption</a></span>
</td>
<td class="description last">NULLABLE. Indicates a Column without NOT NULL constraint.</td>
        </tr>
<tr>
<td class="name"><code>NOT_NULL</code></td>
<td class="type">
<span class="param-type"><a href="#TypeOption">TypeOption</a></span>
</td>
<td class="description last">NOT NULL. Indicates a Column with NOT NULL constraint.</td>
        </tr>
</tbody>
</table>
</div>
</div>
</article>

</section>
<section id="module-undefined-module:griddb_nodejs">
  <a href="#top" class="back-to-top">back to top &#8679;</a>

<header id="griddb-nodejs">
</header>

<article>
    <div class="container-overview">
<h2>griddb_nodejs</h2>
</div>
</article>

</section></div>
<nav><h2><a href="#">Home</a></h2><h3>Modules</h3><ul><li><a href="#griddb-nodejs">griddb_nodejs</a></li></ul><h3>Classes</h3><ul><li><a href="#AggregationResult">AggregationResult</a></li><li><a href="#Container">Container</a></li><li><a href="#GSException">GSException</a></li><li><a href="#PartitionController">PartitionController</a></li><li><a href="#Query">Query</a></li><li><a href="#QueryAnalysisEntry">QueryAnalysisEntry</a></li><li><a href="#RowKeyPredicate">RowKeyPredicate</a></li><li><a href="#RowSet">RowSet</a></li><li><a href="#Store">Store</a></li><li><a href="#StoreFactory">StoreFactory</a></li></ul><h3>Global</h3><ul><li><a href="#ContainerType">ContainerType</a></li><li><a href="#IndexType">IndexType</a></li><li><a href="#RowSetType">RowSetType</a></li><li><a href="#TimeUnit">TimeUnit</a></li><li><a href="#Type">Type</a></li><li><a href="#TypeOption">TypeOption</a></li></ul></nav>
<br class="clear">

<footer>
  Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Tue Oct 20 2015 11:57:24 GMT-0400 (EDT)
</footer>

</body>
</html>
