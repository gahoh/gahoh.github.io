<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>griddb_go - The Go Programming Language</title>
<script type="text/javascript">window.initFuncs = [];</script>
<style>
body {
	margin: 0;
	font-family: Arial, sans-serif;
	font-size: 16px;
	background-color: #fff;
	line-height: 1.3em;
}
pre,
code {
	font-family: Menlo, monospace;
	font-size: 14px;
}
pre {
	line-height: 1.4em;
	overflow-x: auto;
}
pre .comment {
	color: #006600;
}
pre .highlight,
pre .highlight-comment,
pre .selection-highlight,
pre .selection-highlight-comment {
	background: #FFFF00;
}
pre .selection,
pre .selection-comment {
	background: #FF9632;
}
pre .ln {
	color: #999;
	background: #efefef;
}
.ln {
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}
.ln::before {
	/* Inserting the line numbers as a ::before pseudo-element avoids making
	 * them selectable; it's the trick Github uses as well. */
	content: attr(data-content);
}
body {
	color: #222;
}
a,
.exampleHeading .text {
	color: #375EAB;
	text-decoration: none;
}
a:hover,
.exampleHeading .text:hover {
	text-decoration: underline;
}
.article a {
	text-decoration: underline;
}
.article .title a {
	text-decoration: none;
}

.permalink {
	display: none;
}
:hover > .permalink {
	display: inline;
}

p, li {
	max-width: 800px;
	word-wrap: break-word;
}
p,
pre,
ul,
ol {
	margin: 20px;
}
pre {
	background: #EFEFEF;
	padding: 10px;

	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	border-radius: 5px;
}

h1,
h2,
h3,
h4,
.rootHeading {
	margin: 20px 0 20px;
	padding: 0;
	color: #375EAB;
	font-weight: bold;
}
h1 {
	font-size: 28px;
	line-height: 1;
}
h1 .text-muted {
  color:#777;
}
h2 {
	font-size: 20px;
	background: #E0EBF5;
	padding: 8px;
	line-height: 1.25;
	font-weight: normal;
}
h2 a {
	font-weight: bold;
}
h3 {
	font-size: 20px;
}
h3,
h4 {
	margin: 20px 5px;
}
h4 {
	font-size: 16px;
}
.rootHeading {
	font-size: 20px;
	margin: 0;
}

dl {
	margin: 20px;
}
dd {
	margin: 0 0 0 20px;
}
dl,
dd {
	font-size: 14px;
}
div#nav table td {
	vertical-align: top;
}


.pkg-dir {
	padding: 0 10px;
}
.pkg-dir table {
	border-collapse: collapse;
	border-spacing: 0;
}
.pkg-name {
	padding-right: 10px;
}
.alert {
	color: #AA0000;
}

.top-heading {
	float: left;
	padding: 21px 0;
	font-size: 20px;
	font-weight: normal;
}
.top-heading a {
	color: #222;
	text-decoration: none;
}

div#topbar {
/*	background: #E0EBF5; */
	height: 64px;
	overflow: hidden;
}

body {
	text-align: center;
}
div#page {
	width: 100%;
}
div#page > .container,
div#topbar > .container {
	text-align: left;
	margin-left: auto;
	margin-right: auto;
	padding: 0 20px;
}
div#topbar > .container,
div#page > .container {
	max-width: 950px;
}
div#page.wide > .container,
div#topbar.wide > .container {
	max-width: none;
}
div#plusone {
	float: right;
	clear: right;
	margin-top: 5px;
}

div#footer {
	text-align: center;
	color: #666;
	font-size: 14px;
	margin: 40px 0;
}

div#menu > a,
div#menu > input,
div#learn .buttons a,
div.play .buttons a,
div#blog .read a,
#menu-button {
	padding: 10px;

	text-decoration: none;
	font-size: 16px;

	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	border-radius: 5px;
}
div#playground .buttons a,
div#menu > a,
div#menu > input,
#menu-button {
	border: 1px solid #375EAB;
}
div#playground .buttons a,
div#menu > a,
#menu-button {
	color: white;
	background: #375EAB;
}
#playgroundButton.active {
	background: white;
	color: #375EAB;
}
a#start,
div#learn .buttons a,
div.play .buttons a,
div#blog .read a {
	color: #222;
	border: 1px solid #375EAB;
	background: #E0EBF5;
}
.download {
	width: 150px;
}

div#menu {
	text-align: right;
	padding: 10px;
	white-space: nowrap;
	max-height: 0;
	-moz-transition: max-height .25s linear;
	transition: max-height .25s linear;
	width: 100%;
}
div#menu.menu-visible {
	max-height: 500px;
}
div#menu > a,
#menu-button {
	margin: 10px 2px;
	padding: 10px;
}
div#menu > input {
	position: relative;
	top: 1px;
	width: 140px;
	background: white;
	color: #222;
	box-sizing: border-box;
}
div#menu > input.inactive {
	color: #999;
}

#menu-button {
	display: none;
	position: absolute;
	right: 5px;
	top: 0;
	margin-right: 5px;
}
#menu-button-arrow {
	display: inline-block;
}
.vertical-flip {
	transform: rotate(-180deg);
}

div.left {
	float: left;
	clear: left;
	margin-right: 2.5%;
}
div.right {
	float: right;
	clear: right;
	margin-left: 2.5%;
}
div.left,
div.right {
	width: 45%;
}

div#learn,
div#about {
	padding-top: 20px;
}
div#learn h2,
div#about {
	margin: 0;
}
div#about {
	font-size: 20px;
	margin: 0 auto 30px;
}
div#gopher {
	background: url(http://127.0.0.1:6060/doc/gopher/frontpage.png) no-repeat;
	background-position: center top;
	height: 155px;
}
a#start {
	display: block;
	padding: 10px;

	text-align: center;
	text-decoration: none;

	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	border-radius: 5px;
}
a#start .big {
	display: block;
	font-weight: bold;
	font-size: 20px;
}
a#start .desc {
	display: block;
	font-size: 14px;
	font-weight: normal;
	margin-top: 5px;
}

div#learn .popout {
	float: right;
	display: block;
	cursor: pointer;
	font-size: 12px;
	background: url(http://127.0.0.1:6060/doc/share.png) no-repeat;
	background-position: right top;
	padding: 5px 27px;
}
div#learn pre,
div#learn textarea {
	padding: 0;
	margin: 0;
	font-family: Menlo, monospace;
	font-size: 14px;
}
div#learn .input {
	padding: 10px;
	margin-top: 10px;
	height: 150px;

	-webkit-border-top-left-radius: 5px;
	-webkit-border-top-right-radius: 5px;
	-moz-border-radius-topleft: 5px;
	-moz-border-radius-topright: 5px;
	border-top-left-radius: 5px;
	border-top-right-radius: 5px;
}
div#learn .input textarea {
	width: 100%;
	height: 100%;
	border: none;
	outline: none;
	resize: none;
}
div#learn .output {
	border-top: none !important;

	padding: 10px;
	height: 59px;
	overflow: auto;

	-webkit-border-bottom-right-radius: 5px;
	-webkit-border-bottom-left-radius: 5px;
	-moz-border-radius-bottomright: 5px;
	-moz-border-radius-bottomleft: 5px;
	border-bottom-right-radius: 5px;
	border-bottom-left-radius: 5px;
}
div#learn .output pre {
	padding: 0;

	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	border-radius: 0;
}
div#learn .input,
div#learn .input textarea,
div#learn .output,
div#learn .output pre {
	background: #FFFFD8;
}
div#learn .input,
div#learn .output {
	border: 1px solid #375EAB;
}
div#learn .buttons {
	float: right;
	padding: 20px 0 10px 0;
	text-align: right;
}
div#learn .buttons a {
	height: 16px;
	margin-left: 5px;
	padding: 10px;
}
div#learn .toys {
	margin-top: 8px;
}
div#learn .toys select {
	border: 1px solid #375EAB;
	margin: 0;
}
div#learn .output .exit {
	display: none;
}

div#video {
	max-width: 100%;
}
div#blog,
div#video {
	margin-top: 40px;
}
div#blog > a,
div#blog > div,
div#blog > h2,
div#video > a,
div#video > div,
div#video > h2 {
	margin-bottom: 10px;
}
div#blog .title,
div#video .title {
	display: block;
	font-size: 20px;
}
div#blog .when {
	color: #666;
	font-size: 14px;
}
div#blog .read {
	text-align: right;
}

.toggleButton { cursor: pointer; }
.toggle > .collapsed { display: block; }
.toggle > .expanded { display: none; }
.toggleVisible > .collapsed { display: none; }
.toggleVisible > .expanded { display: block; }

table.codetable { margin-left: auto; margin-right: auto; border-style: none; }
table.codetable td { padding-right: 10px; }
hr { border-style: none; border-top: 1px solid black; }

img.gopher {
	float: right;
	margin-left: 10px;
	margin-bottom: 10px;
	z-index: -1;
}
h2 { clear: right; }

/* example and drop-down playground */
div.play {
	padding: 0 20px 40px 20px;
}
div.play pre,
div.play textarea,
div.play .lines {
	padding: 0;
	margin: 0;
	font-family: Menlo, monospace;
	font-size: 14px;
}
div.play .input {
	padding: 10px;
	margin-top: 10px;

	-webkit-border-top-left-radius: 5px;
	-webkit-border-top-right-radius: 5px;
	-moz-border-radius-topleft: 5px;
	-moz-border-radius-topright: 5px;
	border-top-left-radius: 5px;
	border-top-right-radius: 5px;

	overflow: hidden;
}
div.play .input textarea {
	width: 100%;
	height: 100%;
	border: none;
	outline: none;
	resize: none;

	overflow: hidden;
}
div#playground .input textarea {
	overflow: auto;
	resize: auto;
}
div.play .output {
	border-top: none !important;

	padding: 10px;
	max-height: 200px;
	overflow: auto;

	-webkit-border-bottom-right-radius: 5px;
	-webkit-border-bottom-left-radius: 5px;
	-moz-border-radius-bottomright: 5px;
	-moz-border-radius-bottomleft: 5px;
	border-bottom-right-radius: 5px;
	border-bottom-left-radius: 5px;
}
div.play .output pre {
	padding: 0;

	-webkit-border-radius: 0;
	-moz-border-radius: 0;
	border-radius: 0;
}
div.play .input,
div.play .input textarea,
div.play .output,
div.play .output pre {
	background: #FFFFD8;
}
div.play .input,
div.play .output {
	border: 1px solid #375EAB;
}
div.play .buttons {
	float: right;
	padding: 20px 0 10px 0;
	text-align: right;
}
div.play .buttons a {
	height: 16px;
	margin-left: 5px;
	padding: 10px;
	cursor: pointer;
}
.output .stderr {
	color: #933;
}
.output .system {
	color: #999;
}

/* drop-down playground */
#playgroundButton,
div#playground {
	/* start hidden; revealed by javascript */
	display: none;
}
div#playground {
	position: absolute;
	top: 63px;
	right: 20px;
	padding: 0 10px 10px 10px;
	z-index: 1;
	text-align: left;
	background: #E0EBF5;

	border: 1px solid #B0BBC5;
	border-top: none;

	-webkit-border-bottom-left-radius: 5px;
	-webkit-border-bottom-right-radius: 5px;
	-moz-border-radius-bottomleft: 5px;
	-moz-border-radius-bottomright: 5px;
	border-bottom-left-radius: 5px;
	border-bottom-right-radius: 5px;
}
div#playground .code {
	width: 520px;
	height: 200px;
}
div#playground .output {
	height: 100px;
}

/* Inline runnable snippets (play.js/initPlayground) */
#content .code pre, #content .playground pre, #content .output pre {
        margin: 0;
        padding: 0;
        background: none;
        border: none;
	outline: 0px solid transparent;
        overflow: auto;
}
#content .playground .number, #content .code .number {
        color: #999;
}
#content .code, #content .playground, #content .output {
	width: auto;
        margin: 20px;
        padding: 10px;
        -webkit-border-radius: 5px;
        -moz-border-radius: 5px;
        border-radius: 5px;
}
#content .code, #content .playground {
        background: #e9e9e9;
}
#content .output {
        background: #202020;
}
#content .output .stdout, #content .output pre {
        color: #e6e6e6;
}
#content .output .stderr, #content .output .error {
        color: rgb(244, 74, 63);
}
#content .output .system, #content .output .exit {
        color: rgb(255, 209, 77)
}
#content .buttons {
        position: relative;
        float: right;
        top: -50px;
        right: 30px;
}
#content .output .buttons {
        top: -60px;
        right: 0;
        height: 0;
}
#content .buttons .kill {
        display: none;
        visibility: hidden;
}
a.error {
	font-weight: bold;
        color: white;
	background-color: darkred;
        border-bottom-left-radius: 4px;
        border-bottom-right-radius: 4px;
        border-top-left-radius: 4px;
        border-top-right-radius: 4px;
        padding: 2px 4px 2px 4px; /* TRBL */
}


#heading-narrow {
	display: none;
}

.downloading {
	background: #F9F9BE;
	padding: 10px;
	text-align: center;
	border-radius: 5px;
}

@media (max-width: 930px) {
	#heading-wide {
		display: none;
	}
	#heading-narrow {
		display: block;
	}
}


@media (max-width: 760px) {
	.container .left,
	.container .right {
		width: auto;
		float: none;
	}

	div#about {
		max-width: 500px;
		text-align: center;
	}
}

@media (min-width: 700px) and (max-width: 1000px) {
	div#menu > a {
		margin: 5px 0;
		font-size: 14px;
	}

	div#menu > input {
		font-size: 14px;
	}
}

@media (max-width: 700px) {
	body {
		font-size: 15px;
	}

	pre,
	code {
		font-size: 13px;
	}

	div#page > .container {
		padding: 0 10px;
	}

	div#topbar {
		height: auto;
		padding: 10px;
	}

	div#topbar > .container {
		padding: 0;
	}

	#heading-wide {
		display: block;
	}
	#heading-narrow {
		display: none;
	}

	.top-heading {
		float: none;
		display: inline-block;
		padding: 12px;
	}

	div#menu {
		padding: 0;
		min-width: 0;
		text-align: left;
		float: left;
	}

	div#menu > a,
	div#menu > input {
		display: block;
		margin-left: 0;
		margin-right: 0;
	}

	div#menu > input {
		width: 100%;
	}

	#menu-button {
		display: inline-block;
	}

	p,
	pre,
	ul,
	ol {
		margin: 10px;
	}

	.pkg-synopsis {
		display: none;
	}

	img.gopher {
		display: none;
	}
}

@media (max-width: 480px) {
	#heading-wide {
		display: none;
	}
	#heading-narrow {
		display: block;
	}
}

@media print {
	pre {
		background: #FFF;
		border: 1px solid #BBB;
		white-space: pre-wrap;
	}
}

</style>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="#"><h1>GridDB Go API Reference</h1></a></div>
<div class="top-heading" id="heading-narrow"><a href="#"><h1>GridDB Go API Reference</h1></a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h2>
    Package griddb_go
    <span class="text-muted"></span>
  </h2>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>



		<div id="short-nav">
			<dl>
			<dd><code>import "."</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>


			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview">
			<div class="expanded">
				<h2>Overview</h2>
				<p>
Welcome to GO Client&#39;s documentation!
</p>
<p>
GO Client for GridDB is developed using GridDB C Client and SWIG (<a href="http://www.swig.org/">http://www.swig.org/</a>)
</p>
<p>
Available Functions.
</p>
<p>
+ STRING, BOOL, BYTE, SHORT, INTEGER, LONG, FLOAT, DOUBLE, TIMESTAMP, BLOB, type for GridDB.
</p>
<p>
+ Put/get data.
</p>
<p>
+ Normal query, aggregation with TQL.
</p>
<p>
+ Multi-Put/Get/Query (batch processing).
</p>
<p>
Not available function.
</p>
<p>
+ ARRAY type for GridDB.
</p>
<p>
+ Timeseries compression.
</p>
<p>
+ Timeseries-specific function like gsAggregateTimeSeries, gsQueryByTimeSeriesSampling in C Client.
</p>
<p>
+ Trigger, affinity.
</p>
<p>
Note:
</p>
<p>
Nil is used to represent the absence of a value.
Accuracy of TIMESTAMP for GridDB is in milliseconds. A value less than a millisecond will be ignored.
</p>

			</div>
		</div>


		<div id="pkg-index">
		<div class="expanded">
			<h2>Index</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>

				<dd><a href="#pkg-constants">Constants</a></dd>





				<dd><a href="#AggregationResult">type AggregationResult</a></dd>




				<dd><a href="#Container">type Container</a></dd>




				<dd><a href="#ContainerInfo">type ContainerInfo</a></dd>




				<dd><a href="#ExpirationInfo">type ExpirationInfo</a></dd>




				<dd><a href="#GridDB">type GridDB</a></dd>




				<dd><a href="#PartitionController">type PartitionController</a></dd>




				<dd><a href="#Query">type Query</a></dd>




				<dd><a href="#QueryAnalysisEntry">type QueryAnalysisEntry</a></dd>




				<dd><a href="#RowKeyPredicate">type RowKeyPredicate</a></dd>




				<dd><a href="#RowSet">type RowSet</a></dd>




				<dd><a href="#Store">type Store</a></dd>




				<dd><a href="#StoreFactory">type StoreFactory</a></dd>




			</dl>
			</div><!-- #manual-nav -->




			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">

				griddb_go.go

			</span>
			</p>

		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->


			<h2 id="pkg-constants">Constants</h2>

				<p>
Represents the type(s) of indexes set on a Container.
If DEFAULT is specified, the following types of indexes are selected depending on the Container type and corresponding Column type.
</p>
<pre>| (Column) Type  | Collection  | TimeSeries |
| STRING         |   TREE      |  TREE      |
| BOOL           |   TREE      |  TREE      |
| Numeric type   |   TREE      |  TREE      |
| TIMESTAMP      |   TREE      |  TREE      |
| BLOB           |    (-)      |  (-)       |
</pre>

				<pre>const (
    <span class="comment">// Indicates a default index.</span>
    <span id="INDEX_FLAG_DEFAULT">INDEX_FLAG_DEFAULT</span> = -1
    <span class="comment">// Indicates a tree index. This index can be applied to STRING/BOOL/BYTE/SHORT/INTEGER/LONG/FLOAT/DOUBLE/TIMESTAMP types</span>
    <span class="comment">// of Columns of any type of Container, except the Column corresponding to the Row key of TimeSeries.</span>
    <span id="INDEX_FLAG_TREE">INDEX_FLAG_TREE</span> = 1
    <span class="comment">// Indicates a hash index. This type of index can be set on STRING/BOOL/BYTE/SHORT/INTEGER/LONG/FLOAT/DOUBLE/TIMESTAMP types</span>
    <span class="comment">// of Columns in Collection. It cannot be set on Columns in TimeSeries.</span>
    <span id="INDEX_FLAG_HASH">INDEX_FLAG_HASH</span> = 2
)</pre>

				<p>
Represents the type of a Container.
</p>

				<pre>const (
    <span class="comment">// Collection container</span>
    <span id="CONTAINER_COLLECTION">CONTAINER_COLLECTION</span> = 0
    <span class="comment">// TimeSeries container</span>
    <span id="CONTAINER_TIME_SERIES">CONTAINER_TIME_SERIES</span> = 1
)</pre>

				<p>
Represents the type of field values in GridDB.
</p>

				<pre>const (
    <span class="comment">// STRING type</span>
    <span id="TYPE_STRING">TYPE_STRING</span> = 0
    <span class="comment">// Boolean</span>
    <span id="TYPE_BOOL">TYPE_BOOL</span> = 1
    <span class="comment">// BYTE type</span>
    <span id="TYPE_BYTE">TYPE_BYTE</span> = 2
    <span class="comment">// SHORT type</span>
    <span id="TYPE_SHORT">TYPE_SHORT</span> = 3
    <span class="comment">// INTEGER type</span>
    <span id="TYPE_INTEGER">TYPE_INTEGER</span> = 4
    <span class="comment">// LONG type</span>
    <span id="TYPE_LONG">TYPE_LONG</span> = 5
    <span class="comment">// FLOAT type</span>
    <span id="TYPE_FLOAT">TYPE_FLOAT</span> = 6
    <span class="comment">// DOUBLE type</span>
    <span id="TYPE_DOUBLE">TYPE_DOUBLE</span> = 7
    <span class="comment">// TIMESTAMP type</span>
    <span id="TYPE_TIMESTAMP">TYPE_TIMESTAMP</span> = 8
    <span class="comment">// BLOB type</span>
    <span id="TYPE_BLOB">TYPE_BLOB</span> = 10
)</pre>

				<p>
Represents the type of content that can be extracted from RowSet.
</p>

				<pre>const (
    <span class="comment">// Row set in a Container</span>
    <span id="ROW_SET_CONTAINER_ROWS">ROW_SET_CONTAINER_ROWS</span> = 0
    <span class="comment">// Aggregation result</span>
    <span id="ROW_SET_AGGREGATION_RESULT">ROW_SET_AGGREGATION_RESULT</span> = 1
    <span class="comment">// Represents one of information entries composing a query plan and the results of analyzing a query operation.</span>
    <span id="ROW_SET_QUERY_ANALYSIS">ROW_SET_QUERY_ANALYSIS</span> = 2
)</pre>

				<p>
Represents the unit of the elapsed time period of a Row to be used as the basis of the validity period.
</p>

				<pre>const (
    <span id="TIME_UNIT_YEAR">TIME_UNIT_YEAR</span>        = 0
    <span id="TIME_UNIT_MONTH">TIME_UNIT_MONTH</span>       = 1
    <span id="TIME_UNIT_DAY">TIME_UNIT_DAY</span>         = 2
    <span id="TIME_UNIT_HOUR">TIME_UNIT_HOUR</span>        = 3
    <span id="TIME_UNIT_MINUTE">TIME_UNIT_MINUTE</span>      = 4
    <span id="TIME_UNIT_SECOND">TIME_UNIT_SECOND</span>      = 5
    <span id="TIME_UNIT_MILLISECOND">TIME_UNIT_MILLISECOND</span> = 6
)</pre>

				<p>
Represents NOT NULL constrant.
</p>

				<pre>const (
    <span class="comment">// Nullable. Indicates a Column without NOT NULL constraint.</span>
    <span id="TYPE_OPTION_NULLABLE">TYPE_OPTION_NULLABLE</span> = 2
    <span class="comment">// NOT NULL. Indicates a Column with NOT NULL constraint.</span>
    <span id="TYPE_OPTION_NOT_NULL">TYPE_OPTION_NOT_NULL</span> = 4
)</pre>







			<h2 id="AggregationResult">type AggregationResult
				<a class="permalink" href="#AggregationResult">&#xb6;</a>
			</h2>
			<p>
Stores the result of an aggregation operation.
The type of the stored result depends on the type of aggregation operation and the type of the target Columns.
For specific rules, see the TQL specifications.
The type of obtaining value depends on the stored type.
Float type and long type are only available when a result is of numeric type, and datetime type when a result is of TIMESTAMP type.
</p>

			<pre>type AggregationResult interface {
    <span class="comment">// Returns the aggregation result as the value with specified type.</span>
    Get(int) (interface{}, error)
}</pre>















			<h2 id="Container">type Container
				<a class="permalink" href="#Container">&#xb6;</a>
			</h2>
			<p>
Container Provides management functions for sets of row having same type.
Each column in GridDB schema is defined by a ContainerInfo. Each container consists of one or more columns.
Mapping table between column type and value in a row object is following:
</p>
<pre>| (Column) Type   |      string         |      bool           |        int          |       float64       |      time.Time      |       []byte        |
| STRING          |   mapped(default)   |                     |                     |                     |                     |                     |
| BOOL            |                     |   mapped(default)   |      mapped         |                     |                     |                     |
| BYTE            |                     |                     |   mapped(default)   |                     |                     |                     |
| SHORT           |                     |                     |   mapped(default)   |                     |                     |                     |
| INTEGER         |                     |                     |   mapped(default)   |                     |                     |                     |
| LONG            |                     |                     |   mapped(default)   |                     |                     |                     |
| FLOAT           |                     |                     |      mapped         |   mapped(default)   |                     |                     |
| DOUBLE          |                     |                     |      mapped         |   mapped(default)   |                     |                     |
| TIMESTAMP       |      mapped         |                     |      mapped         |        mapped       |   mapped(default)   |                     |
| BLOB            |      mapped         |                     |                     |                     |                     |   mapped(default)   |
</pre>
<p>
Note:
</p>
<p>
&#34;default&#34; is the Go type of return value for data query from GridDB. For example: BYTE, SHORT, INTEGER, LONG is
returned as GO int when query data from GridDB
</p>
<p>
TIMESTAMP represents milliseconds since the UNIX epoch (January 1, 1970 00:00:00 UTC) with long type.
TIMESTAMP value suports msec. Range of time is from 1/1/1970 to 12/31/9999 (UTC).
</p>
<p>
There may be more limitation depending on a GridDB cluster configuration.
GridDB cannot store a value out of the range set by those configuration.
</p>
<p>
There is an upper limit for the number of column and the length of column name.
The value also has limitations for range and size. Please refer to appendix of GridDB API Reference for more detail.
GridDB cannot store a value exceeding these limitations.
</p>
<p>
NULL in GridDB rows can be stored unless the NOT NULL constraint is set.
NOT NULL constraint can be set with columnInfoList object in ContainerInfo when PutContainer() is called.
</p>
<p>
About transaction, auto commit mode is active as a default.
In the auto commit mode, each transaction is processed sequentially, and cannot be canceled.
For manual commit mode, transactions before a commit is canceled if there is an error on a cluster node during the transaction via Container instances.
Transaction isolation level supports only READ COMMITTED. Lock granularity may differ for each container type.
</p>
<p>
When a row is updated, added, deleted, and got a lock for updates, a transaction is generated internally.
This transaction has a valid period.
After some period defined by GridDB is passed from the timing of this transaction for Container instance, any same type of transactions will be not accepted.
</p>

			<pre>type Container interface {
    <span class="comment">// Removes a Row corresponding to Row key.</span>
    <span class="comment">// In the manual commit mode, the target Row is locked.</span>
    Get(interface{}) (row []interface{}, err error)

    <span class="comment">// Newly creates or update a Row.</span>
    <span class="comment">// If a Column exists which corresponds to the specified Row key, it determines</span>
    <span class="comment">// whether to newly create or update a Row, based on the Row key and the state of</span>
    <span class="comment">// the Container. If there is no corresponding Row in the Container, it determines</span>
    <span class="comment">// to newly create a Row; otherwise, it updates a relevant Row.</span>
    <span class="comment">//</span>
    <span class="comment">// If no Column exists which corresponds to the specified Row key, it always creates a new Row.</span>
    <span class="comment">// In the manual commit mode, the target Row is locked.</span>
    Put(row []interface{}) (err error)

    <span class="comment">// Newly creates an arbitrary number of Rows together based on the specified Row objects group.</span>
    <span class="comment">// In the manual commit mode, the target Row is locked.</span>
    MultiPut(rowList [][]interface{}) (err error)

    <span class="comment">// Creates a query to execute the specified TQL statement.</span>
    Query(str string) (mQuery <a href="#Query">Query</a>, err error)

    <span class="comment">// Removes a Row corresponding to Row key.</span>
    <span class="comment">// In the manual commit mode, the target Row is locked.</span>
    Remove(key interface{}) (err error)

    <span class="comment">// Creates a specified type of index on the specified Column.</span>
    <span class="comment">// Named index can be set with name parameter.</span>
    <span class="comment">// No index cannot be set on a TimeSeries Row key (TIMESTAMP type).</span>
    <span class="comment">// When a transaction is held, uncommitted updates will be rolled back.</span>
    <span class="comment">// If an index is already set on the specified Column, nothing is changed.</span>
    <span class="comment">//</span>
    <span class="comment">// When a transaction(s) is active in a target Container, it creates an index after</span>
    <span class="comment">// waiting for the transaction(s) to complete.</span>
    CreateIndex(a ...interface{}) (err error)

    <span class="comment">// Removes the specified type of index among indexes on the specified Column.</span>
    <span class="comment">// Nothing is changed if the specified index is not found.</span>
    <span class="comment">//</span>
    <span class="comment">// When a transaction(s) is active in a target Container, it removes the index after</span>
    <span class="comment">// waiting for the transaction(s) to be completed.</span>
    DropIndex(a ...interface{}) (err error)

    <span class="comment">// Writes the results of earlier updates to a non-volatile storage medium, such as SSD,</span>
    <span class="comment">// so as to prevent the data loss even if all cluster nodes stop suddenly.</span>
    <span class="comment">//</span>
    <span class="comment">// It can be used for operations which require higher reliability than usual. However,</span>
    <span class="comment">// frequent execution of this operation would potentially cause degradation in response time.</span>
    <span class="comment">//</span>
    <span class="comment">// The details of behavior, such as the scope of cluster nodes which are the data export targets,</span>
    <span class="comment">// will be changed depending on the configuration of GridDB.</span>
    Flush() (err error)
    <span class="comment">// Get type of Container</span>
    GetType() (xType int, err error)
    <span class="comment">// Rolls back the result of the current transaction and starts a new transaction in the manual commit mode.</span>
    Abort() (err error)
    <span class="comment">// Commits the result of the current transaction and start a new transaction in the manual commit mode.</span>
    Commit() (err error)

    <span class="comment">// Change the setting of the commit mode.</span>
    <span class="comment">// In the auto commit mode, the transaction state cannot be controlled directly and</span>
    <span class="comment">// change operations are committed sequentially.</span>
    <span class="comment">//</span>
    <span class="comment">// If the auto commit mode is disabled, i.e. in the manual commit mode, as long as</span>
    <span class="comment">// the transaction has not timed out or commit() has been</span>
    <span class="comment">//</span>
    <span class="comment">// invoked directly, the same transaction will continue to be used in this Container and</span>
    <span class="comment">// change operations will not be commited.</span>
    <span class="comment">//</span>
    <span class="comment">// When the auto commit mode is switched from disabled to enabled, uncommitted updates</span>
    <span class="comment">// are committed implicitly. Unless the commit mode is changed, the state of the transaction</span>
    <span class="comment">// will not be changed.</span>
    SetAutoCommit(enabled bool) (err error)
}</pre>















			<h2 id="ContainerInfo">type ContainerInfo
				<a class="permalink" href="#ContainerInfo">&#xb6;</a>
			</h2>
			<p>
Represents the information about a Container.
</p>

			<pre>type ContainerInfo interface {
    SetColumnInfoList(columnInfoList [][]interface{}) (err error)
    SetName(name string)
    GetName() (name string)
    GetColumnInfoList() (columnInfoList [][]interface{})
    GetType() (xType int)
    SetType(xType int)
    SetRowKeyAssigned(rowKeyAssigned bool)
    GetRowKeyAssigned() (rowKeyAssigned bool)
    <span class="comment">// Currently, it is not possible to set ExpirationInfo to nil, if nil is input, an error will be returned</span>
    SetExpirationInfo(expirationInfo <a href="#ExpirationInfo">ExpirationInfo</a>) (err error)
    <span class="comment">// Return nil if ContainerInfo is created without ExpirationInfo</span>
    GetExpirationInfo() (expirationInfo <a href="#ExpirationInfo">ExpirationInfo</a>, err error)
}</pre>















			<h2 id="ExpirationInfo">type ExpirationInfo
				<a class="permalink" href="#ExpirationInfo">&#xb6;</a>
			</h2>
			<p>
Represents the information about a expiration.
</p>

			<pre>type ExpirationInfo interface {
    GetTime() (time int)
    SetTime(time int)
    GetTimeUnit() (timeUnit int)
    SetTimeUnit(timeUnit int)
    GetDivisionCount() (divisionCount int)
    SetDivisionCount(divisionCount int)
}</pre>















			<h2 id="GridDB">type GridDB
				<a class="permalink" href="#GridDB">&#xb6;</a>
			</h2>
			<p>
Static function in GridDB_GO package
</p>

			<pre>type GridDB interface {
    <span class="comment">// Returns a default StoreFactory instance</span>
    StoreFactoryGetInstance() (factory <a href="#StoreFactory">StoreFactory</a>)

    <span class="comment">// Get millisecond since January 1, 1970 UTC from GO datetime object.</span>
    GetTimeMillis(mTime time.Time) (mResult int)

    <span class="comment">// Create ContainerInfo object</span>
    CreateContainerInfo(a ...interface{}) (result <a href="#ContainerInfo">ContainerInfo</a>, err error)

    <span class="comment">// Create ExpirationInfo object</span>
    CreateExpirationInfo(a ...interface{}) (result <a href="#ExpirationInfo">ExpirationInfo</a>, err error)

    <span class="comment">// Delete StoreFactory object</span>
    DeleteStoreFactory(factory <a href="#StoreFactory">StoreFactory</a>)

    <span class="comment">// Delete Store object</span>
    DeleteStore(store <a href="#Store">Store</a>)

    <span class="comment">// Delete Container object</span>
    DeleteContainer(col <a href="#Container">Container</a>)

    <span class="comment">// Delete ContainerInfo object</span>
    DeleteContainerInfo(colInfo <a href="#ContainerInfo">ContainerInfo</a>)

    <span class="comment">// Delete ExpirationInfo object</span>
    DeleteExpirationInfo(expiration <a href="#ExpirationInfo">ExpirationInfo</a>)

    <span class="comment">// Delete AggregationResult object</span>
    DeleteAggregationResult(agg <a href="#AggregationResult">AggregationResult</a>)

    <span class="comment">// Delete QueryAnalysisEntry object</span>
    DeleteQueryAnalysisEntry(entry <a href="#QueryAnalysisEntry">QueryAnalysisEntry</a>)

    <span class="comment">// Delete PartitionController object</span>
    DeletePartitionController(partition <a href="#PartitionController">PartitionController</a>)

    <span class="comment">// Delete Query object</span>
    DeleteQuery(query <a href="#Query">Query</a>)

    <span class="comment">// Delete RowKeyPredicate object</span>
    DeleteRowKeyPredicate(predicate <a href="#RowKeyPredicate">RowKeyPredicate</a>)

    <span class="comment">// Delete RowSet object</span>
    DeleteRowSet(rowset <a href="#RowSet">RowSet</a>)
}</pre>















			<h2 id="PartitionController">type PartitionController
				<a class="permalink" href="#PartitionController">&#xb6;</a>
			</h2>
			<p>
Controller for acquiring and processing the partition status.
A partition is a theoretical region where data is stored. It is used to
perform operations based on the data arrangement in a GridDB cluster.
</p>

			<pre>type PartitionController interface {
    <span class="comment">// Get a list of the Container names belonging to a specified partition.</span>
    <span class="comment">// For the specified partition, the sequence of the list of acquisition results</span>
    <span class="comment">// before and after will not be changed when the relevant Container is excluded even</span>
    <span class="comment">// if a Container is newly created, its composition changed or the Container is deleted.</span>
    <span class="comment">// All other lists are compiled in no particular order. No duplicate names will be included.</span>
    <span class="comment">//</span>
    <span class="comment">// If the upper limit of the number of acquisition cases is specified, the cases</span>
    <span class="comment">// will be cut off starting from the ones at the back if the upper limit is exceeded.</span>
    <span class="comment">// If no relevant specified condition exists, a blank list is returned.</span>
    GetContainerNames(a ...interface{}) (stringList []string, err error)

    <span class="comment">// Get the total number of containers belonging to a specified partition.</span>
    <span class="comment">// The calculated quantity when determining the number of containers is generally not dependent</span>
    <span class="comment">// on the number of containers.</span>
    GetContainerCount(partition_index int) (count int64, err error)

    <span class="comment">// Get the partition index corresponding to the specified Container name.</span>
    <span class="comment">// Once a GridDB cluster is constructed, there will not be any changes in the</span>
    <span class="comment">// partitions of the destination that the Container belongs to and the partition</span>
    <span class="comment">// index will also be fixed. Whether there is a Container corresponding to the</span>
    <span class="comment">// specified name or not does not depend on the results.</span>
    <span class="comment">//</span>
    <span class="comment">// Information required in the computation of the partition index is cached and</span>
    <span class="comment">// until the next cluster failure and cluster node failure is detected, no inquiry</span>
    <span class="comment">// will be sent to the GridDB cluster again.</span>
    GetPartitionIndexOfContainer(container_name string) (ret int, err error)

    <span class="comment">// Get partition count</span>
    <span class="comment">// Get the number of partitions in the target GridDB cluster.</span>
    GetPartitionCount() (partitionCount int, err error)
}</pre>















			<h2 id="Query">type Query
				<a class="permalink" href="#Query">&#xb6;</a>
			</h2>
			<p>
Provides the functions of holding the information about a query related to
a specific Container, specifying the options for fetching and retrieving the result.
</p>

			<pre>type Query interface {
    <span class="comment">// It locks all target Rows if True is specified as forUpdate . If the target</span>
    <span class="comment">// Rows are locked, update operations on the Rows by any other transactions are</span>
    <span class="comment">// blocked while a relevant transaction is active. True can be specified only if</span>
    <span class="comment">// the auto commit mode is disabled on a relevant Container.</span>
    <span class="comment">//</span>
    <span class="comment">// When new set of Rows are obtained, any Row operation via RowSet as the last result</span>
    <span class="comment">// of specified query is prohibited.</span>
    <span class="comment">//</span>
    <span class="comment">// If the system tries to acquire a large number of Rows all at once, the upper limit</span>
    <span class="comment">// of the communication buffer size managed by the GridDB node may be reached,</span>
    <span class="comment">// possibly resulting in a failure. Refer to &#34;System limiting values&#34; in the</span>
    <span class="comment">// Appendix of GridDB API Reference for the upper limit size.</span>
    Fetch(a ...interface{}) (mRowSet <a href="#RowSet">RowSet</a>, err error)

    <span class="comment">// Sets an fetch options for a result acquisition.</span>
    <span class="comment">// Once RowSet is returned, it cannot be obtained until the new query is executed.</span>
    SetFetchOptions(a ...interface{}) (err error)
    <span class="comment">// Returns RowSet as the latest result.</span>
    <span class="comment">// Once RowSet is returned, it cannot be obtained until the new query is executed.</span>
    <span class="comment">// If the query is not fetched, return value is nil</span>
    GetRowSet() (rowSet <a href="#RowSet">RowSet</a>, err error)
}</pre>















			<h2 id="QueryAnalysisEntry">type QueryAnalysisEntry
				<a class="permalink" href="#QueryAnalysisEntry">&#xb6;</a>
			</h2>
			<p>
Represents one of information entries composing a query plan and the results of analyzing a query operation.
</p>

			<pre>type QueryAnalysisEntry interface {
    <span class="comment">// Returns one of information entries composing a query plan and the results of analyzing a query operation.</span>
    Get() (info []interface{}, err error)
}</pre>















			<h2 id="RowKeyPredicate">type RowKeyPredicate
				<a class="permalink" href="#RowKeyPredicate">&#xb6;</a>
			</h2>
			<p>
Represents the condition that a row key satisfies.
This is used as the search condition in Store.multi_get().
There are two types of conditions, range condition and individual condition. The two types
of conditions cannot be specified at the same time. If the condition is not specified, it means
that the condition is satisfied in all the target row keys.
</p>

			<pre>type RowKeyPredicate interface {
    <span class="comment">// Returns the value of Row key at the start and end position of the range condition.</span>
    GetRange() (rangeResult []interface{}, err error)

    <span class="comment">// Sets list of the elements in the individual condition.</span>
    GetDistinctKeys() (keys []interface{}, err error)

    <span class="comment">// Get type of RowkeyPredicate</span>
    GetKeyType() (gsType int)

    <span class="comment">// Sets the value of Row key as the start and end position of the range conditions.</span>
    <span class="comment">// If the row key type is Timestamp, input can be integer. The input will be treated</span>
    <span class="comment">// as number of seconds from 1/1/1970</span>
    SetRange(startKey interface{}, finishKey interface{}) (err error)

    <span class="comment">// Returns a list of the values of the Row keys that configure the individual condition.</span>
    <span class="comment">// If the row key type is Timestamp, input can be integer. The input will be treated</span>
    <span class="comment">// as number of seconds from 1/1/1970</span>
    SetDistinctKeys(keys []interface{}) (err error)
}</pre>















			<h2 id="RowSet">type RowSet
				<a class="permalink" href="#RowSet">&#xb6;</a>
			</h2>
			<p>
Manages a set of Rows obtained by a query.
It has a function of per-Row and per-Row-field manipulation and holds a cursor
state to specify a target Row.
</p>
<p>
The cursor is initially located just before the head of a Row set.
</p>

			<pre>type RowSet interface {
    <span class="comment">// Updates the values except a Row key of the Row at the cursor position, using the specified Row object.</span>
    Update(row []interface{}) (err error)

    <span class="comment">// Moves the cursor to the next Row in a Row set and returns the Row object at the moved position.</span>
    NextRow() (row []interface{}, err error)

    <span class="comment">// Moves the cursor to the next Row in a Row set and returns the Row object at the moved position.</span>
    NextQueryAnalysis() (mQueryAnalysis <a href="#QueryAnalysisEntry">QueryAnalysisEntry</a>, err error)

    <span class="comment">// Moves the cursor to the next Row in a Row set and returns the Row object at the moved position.</span>
    NextAggregation() (mAggregationResult <a href="#AggregationResult">AggregationResult</a>, err error)

    <span class="comment">// Delete current row data.</span>
    Remove() (err error)

    <span class="comment">// Get type of row set</span>
    Xtype() (rowsetType int)

    <span class="comment">// Get size of row set</span>
    <span class="comment">// The number of Row when a Row set is created</span>
    Size() (size int)

    <span class="comment">// Returns whether a Row set has at least one Row ahead of the current cursor position.</span>
    HasNext() (hasNext bool)
}</pre>















			<h2 id="Store">type Store
				<a class="permalink" href="#Store">&#xb6;</a>
			</h2>
			<p>
Provides functions to manipulate the entire data managed in one GridDB system.
A function to add, delete, or change the composition of Collection and TimeSeries Containers as well as
to process the Rows constituting a Container is provided.
Regardless of container types, etc., multiple container names different only in uppercase and
lowercase ASCII characters cannot be defined in a database.  See the GridDB Technical Reference for
the details. In the operations specifying a container name, uppercase and lowercase ASCII characters are
identified as the same unless otherwise noted.
Thread safety of each method is not guaranteed.
</p>

			<pre>type Store interface {
    <span class="comment">// New creation or update operation is carried out on an arbitrary number of rows of a Container,</span>
    <span class="comment">// with the request unit enlarged as much as possible.</span>
    <span class="comment">//</span>
    <span class="comment">// For each Row object included in a specified entry column, a new creation or update operation is</span>
    <span class="comment">// carried out just like the case when Container.put() is invoked individually. However, unlike</span>
    <span class="comment">// the case when carried out individually, the target node is requested for the same storage destination, etc. with</span>
    <span class="comment">// a unit that is as large as possible. Based on this, the larger the total number of Row objects specified and</span>
    <span class="comment">// the larger the total number of target Containers, the higher is the possibility that the number of</span>
    <span class="comment">// correspondences with the target node will be reduced.</span>
    <span class="comment">//</span>
    <span class="comment">// A specified entry column is composed of an arbitrary number of entries that adopt the Container name as</span>
    <span class="comment">// its key and the column of Row objects as its value. A subject Container may be a mixture of different</span>
    <span class="comment">// Container types and column layouts. However, the Containers must already exist. NULL can not be set as</span>
    <span class="comment">// the Container name in the entry column. Also NULL can not be set as the array address to the column of</span>
    <span class="comment">// Row objects if the number of elements in the column of Row objects is positive value.</span>
    <span class="comment">//</span>
    <span class="comment">// An arbitrary number of Row with the same column layout as the subject Container can be included in each</span>
    <span class="comment">// column of Row objects. In the current version, all the column order must also be the same. The Container cannot</span>
    <span class="comment">// include NULL as an element of the column of Row objects. Depending on the Container type and setting, the same</span>
    <span class="comment">// restrictions as Container.put() are established for the contents of Rows that can be operated. If there are</span>
    <span class="comment">// multiple columns of Row objects having the same Row key targeting the same Container in the designated entry column,</span>
    <span class="comment">// the contents of the rear-most Row object having a Row key with the same value will be reflected using the element order of</span>
    <span class="comment">// entry column as a reference if it is between different lists, or the element order of the column of Row object as a reference if</span>
    <span class="comment">// it is within the same column of Row object. The transaction cannot be maintained and the lock cannot continue to be</span>
    <span class="comment">// retained. However, if the lock that affects the target Row is secured by an existing transaction, the system will</span>
    <span class="comment">// continue to wait for all the locks to be released. Like other Container or Row operations, consistency between Containers is</span>
    <span class="comment">// not guaranteed. Therefore, the processing results for a certain Container may be affected by other operation commands that</span>
    <span class="comment">// have been completed prior to the start of the process. If an error occurs in the midst of processing a Container and</span>
    <span class="comment">// its Rows, only the results for some of the Rows of some of the Containers may remain reflected.</span>
    MultiPut(map[string][][]interface{}) (err error)

    <span class="comment">// Returns an arbitrary number and range of Rows in any Container based on the specified conditions, with</span>
    <span class="comment">// the request unit enlarged as much as possible.</span>
    <span class="comment">// Returns the Row contents in accordance with the conditions included in the specified entry column, similar to</span>
    <span class="comment">// invoking Container.get() or Query.fetch() individually. However, unlike the case when carried out individually,</span>
    <span class="comment">// the target node is requested for the same storage destination, etc. with a unit that is as large as possible.</span>
    <span class="comment">// Based on this, the larger the total number of Rows conforming to the conditions and the larger the total number</span>
    <span class="comment">// of target Containers, the higher is the possibility that the number of correspondences with the target node will</span>
    <span class="comment">// be reduced.</span>
    <span class="comment">//</span>
    <span class="comment">// A specified condition entry column is composed of an arbitrary number of condition entries that adopt</span>
    <span class="comment">// the Container name as the key and the acquisition condition represented by RowKeyPredicate as the value.</span>
    <span class="comment">// Multiple instances with the same RowKeyPredicate can also be included. In addition, a subject Container</span>
    <span class="comment">// may be a mixture of different Container types and column layouts. However, there are some acquisition</span>
    <span class="comment">// conditions that cannot be evaluated due to the composition of the Container. Refer to the definitions of</span>
    <span class="comment">// the various setting functions for RowKeyPredicate for the specific restrictions. In addition, the</span>
    <span class="comment">// specified Container name must be a real Container. It is prohibited to set NULL in the Container name or</span>
    <span class="comment">// the acquisition condition.</span>
    <span class="comment">//</span>
    <span class="comment">// An acquired entry column is composed of entries that adopt the Container name as its key and column of</span>
    <span class="comment">// Row objects as its value. All entries included in a specified entry as acquisition conditions are</span>
    <span class="comment">// included in an acquired entry column. If multiple entries pointing the same Container are included in</span>
    <span class="comment">// a specified condition entry column, a single entry consolidating these is stored in the acquired entry</span>
    <span class="comment">// column. If multiple Row objects are included in the same list, the stored order follows the Container</span>
    <span class="comment">// type and the definition of the individual Container type derived from the corresponding Container.</span>
    <span class="comment">// If there is no Row corresponding to the specified Container, the number of elements in corresponding</span>
    <span class="comment">// column of Row object will be 0.</span>
    <span class="comment">//</span>
    <span class="comment">// Like other Container or Row operations, consistency between Containers is not guaranteed. Therefore,</span>
    <span class="comment">// the processing results for a certain Container may be affected by other operation commands that have</span>
    <span class="comment">// been completed prior to the start of the process.</span>
    <span class="comment">//</span>
    <span class="comment">// Like Container.get() or Query.fetch() , a transaction cannot be maintained and requests for updating</span>
    <span class="comment">// locks cannot be made.</span>
    <span class="comment">//</span>
    <span class="comment">// If the system tries to acquire a large number of Rows all at once, the upper limit of the communication</span>
    <span class="comment">// buffer size managed by the GridDB node may be reached, possibly resulting in a failure. Refer to &#34;System</span>
    <span class="comment">// limiting values&#34; in the Appendix of GridDB API Reference for the upper limit size.</span>
    MultiGet(map[string]<a href="#RowKeyPredicate">RowKeyPredicate</a>) (mapRowList map[string][][]interface{}, err error)

    <span class="comment">// Newly creates or update a Container with the specified ContainerInfo.</span>
    <span class="comment">// It can be used only for RowSet obtained with locking enabled.</span>
    PutContainer(a ...interface{}) (container <a href="#Container">Container</a>, err error)

    <span class="comment">// Get a Container instance whose Rows can be processed using a Row.</span>
    <span class="comment">// If a not-existed container name is input, no error happen and nil will be return.</span>
    GetContainer(containerName string) (container <a href="#Container">Container</a>, err error)

    <span class="comment">// Delete a Container with the specified name.</span>
    <span class="comment">//</span>
    <span class="comment">// If the specified Container is already deleted, nothing is changed.</span>
    <span class="comment">//</span>
    <span class="comment">// When a transaction(s) is active in a target Container, it deletes the Container after waiting for the</span>
    <span class="comment">// transaction completion.</span>
    DropContainer(containerName interface{}) (err error)

    <span class="comment">// Query execution and fetch is carried out on a specified arbitrary number of Query , with the</span>
    <span class="comment">// request unit enlarged as much as possible.</span>
    <span class="comment">//</span>
    <span class="comment">// For each Query included in a specified query column, perform a similar query execution and fetch</span>
    <span class="comment">// as when Query.fetch() is performed individually and set the RowSet in the results. Use get_row_set()</span>
    <span class="comment">// to extract the execution results of each Query . However, unlike the case when carried out individually,</span>
    <span class="comment">// the target node is requested for the same storage destination, etc. with a unit that is as large as</span>
    <span class="comment">// possible. Based on this, the larger the number of elements in the list, the higher is the possibility</span>
    <span class="comment">// that the number of correspondences with the target node will be reduced. Query in a list are not</span>
    <span class="comment">// executed in any particular order.</span>
    <span class="comment">//</span>
    <span class="comment">// Only a Query that has not been closed, including corresponding Container acquired via the specified</span>
    <span class="comment">// Store instance, can be included in a specified query column. Like a fetch() , the Row operations via</span>
    <span class="comment">// RowSet finally generated and held by each Query will be unavailable. If the same instance is included</span>
    <span class="comment">// multiple times in an array, the behavior will be the same as the case in which the respective instances</span>
    <span class="comment">// differ.</span>
    <span class="comment">//</span>
    <span class="comment">// Like other Container or Row operations, consistency between Containers is not guaranteed. Therefore,</span>
    <span class="comment">// the processing results for a certain Container may be affected by other operation commands that have</span>
    <span class="comment">// been completed prior to the start of the process.</span>
    <span class="comment">//</span>
    <span class="comment">// The commit mode of each Container corresponding to the specified Query can be used in either the auto</span>
    <span class="comment">// commit mode or manual commit mode. The transaction status is reflected in the execution results of the</span>
    <span class="comment">// query. If the operation is completed normally, the corresponding transaction of each Container will</span>
    <span class="comment">// not be aborted so long as the transaction timeout time has not been reached.</span>
    <span class="comment">//</span>
    <span class="comment">// If an exception occurs in the midst of processing each Query , a new RowSet may be set for only</span>
    <span class="comment">// some of the Query . In addition, uncommitted transactions of each Query corresponding to the</span>
    <span class="comment">// designated Container may be aborted.</span>
    <span class="comment">//</span>
    <span class="comment">// If the system tries to acquire a large number of Rows all at once, the upper limit of the</span>
    <span class="comment">// communication buffer size managed by the GridDB node may be reached, possibly resulting in a failure.</span>
    <span class="comment">// Refer to &#34;System limiting values&#34; in the Appendix of GridDB API Reference for the upper limit size.</span>
    FetchAll(listQuery []<a href="#Query">Query</a>) (err error)

    <span class="comment">// Get information related to a Container with the specified name.</span>
    <span class="comment">// A name stored in GridDB is set for the Container name to be included in a returned ContainerInfo .</span>
    <span class="comment">// Therefore, compared to the specified Container name, the notation of the ASCII uppercase characters</span>
    <span class="comment">// and lowercase characters may differ.</span>
    <span class="comment">//</span>
    <span class="comment">// When a transaction(s) is active in a target Container, it deletes the Container after waiting for</span>
    <span class="comment">// the transaction completion.</span>
    <span class="comment">//</span>
    <span class="comment">// If a not-existed container name is input, no error happen and nil will be return.</span>
    GetContainerInfo(conName string) (containerInfo <a href="#ContainerInfo">ContainerInfo</a>, err error)

    <span class="comment">// Get Partition controller.</span>
    PartitionInfo() (partitionController <a href="#PartitionController">PartitionController</a>, err error)

    <span class="comment">// Creates a matching condition with the specified Type as the type of Row key.</span>
    <span class="comment">// The target Container must have a Row key, and it must be the same type as the specified Type.</span>
    <span class="comment">// The type of Row key that can be set must be the same type that is allowed by the individual</span>
    <span class="comment">// Container type derived from Container.</span>
    CreateRowKeyPredicate(mType int) (predicate <a href="#RowKeyPredicate">RowKeyPredicate</a>, err error)
}</pre>















			<h2 id="StoreFactory">type StoreFactory
				<a class="permalink" href="#StoreFactory">&#xb6;</a>
			</h2>
			<p>
Manage a Store instance.
It manages the client settings shared by Store instances and used connections.
To access GridDB, you need to get a Store instance using this Factory.
</p>

			<pre>type StoreFactory interface {
    <span class="comment">// Returns a Store with the specified properties.</span>
    <span class="comment">// When obtaining Store, it just searches for the name of a master node (hereafter, a master)</span>
    <span class="comment">// administering each Container as necessary, but authentication is not performed. When a client</span>
    <span class="comment">// really needs to connect to a node corresponding to each Container , authentication is performed.</span>
    <span class="comment">//</span>
    <span class="comment">// A new Store instance is created by each call of this method. Operations on different</span>
    <span class="comment">// Store instances and related resources are thread safe. That is, if some two resources are</span>
    <span class="comment">// each created based on Store instances or they are just Store instances, and if they are</span>
    <span class="comment">// related to different Store instances respectively, any function related to one resource can be</span>
    <span class="comment">// called, no matter when a function related to the other resource may be called from any thread.</span>
    <span class="comment">// However, since thread safety is not guaranteed for Store itself, it is not allowed to call</span>
    <span class="comment">// a method of a single Store instance from two or more threads at an arbitrary time.</span>
    GetStore(a ...interface{}) (ret <a href="#Store">Store</a>, err error)

    <span class="comment">// Returns the version of this client.</span>
    GetVersion() (version string)
}</pre>


</div><!-- .container -->
</div><!-- #page -->


</body>
</html>
